[Back(메인으로)](/README.md)  

# 0x00 오리엔테이션

강의에서는 C++로된 코드만 제공함.  
문제를 많이 풀어봐야함.  
맞은문제도 다른사람 코드를 보고, 좋은코드는 흡수하면서, 최적화된 코딩스타일을 계속 구축해가는게 좋음.  
`#include<bits/stdc++.h>` 왠만한 헤더들을 합쳐놓은 헤더.  
바킹독 본인은 visual code를 사용함.

# 0x01 기초코드작성요령1

빅오표기법, 시간복잡도, 공간복잡도.

## 정수자료형

- 범위를 넘어서게될때 오버플로우는, 에러를 띄우지않아서, 유의해서 사용.

| 자료형    | 크기         | 범위                                                   | 설명                            |
| --------- | ------------ | ------------------------------------------------------ | ------------------------------- |
| char      | 1byte = 8bit | 0 ~ 255                                                |                                 |
| short     | 2byte        | -32,768 ~ 32,767                                       |                                 |
| int       | 4byte        | -2,147,483,648 ~ 2,147,483,647                         |                                 |
| long long | 8byte        | -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 | int범위를 넘어설때 longlong사용 |

## 실수자료형

- 실수의 저장/연산과정에서 반드시 오차가 발생할수밖에 없다.
- 과학적표기법을 따름. exponent=지수부분, fraction=유효숫자부분
- 알고리즘문제에서는 double 대신 float를 써야하는경우는 전혀없음. -> 실수를 사용해야한다면 double!
- ll을 double에 담으면, 오차발생가능.
- int를 double에 담으면, 오차발생X.
- 실수비교떄는 등호사용X. 대략,,`if(abs(a-b) < 1e-12)`이면 동일처리하면 안전.

  | 자료형 | 크기  | 범위                                | 설명            |
  | ------ | ----- | ----------------------------------- | --------------- |
  | float  | 4byte | sign(1), exponent(8), fraction(23)  | 유효숫자 6자리  |
  | double | 8byte | sign(1), exponent(11), fraction(52) | 유효숫자 15자리 |

# 0x02 기초코드작성요령2

swap1은 원본수정하지않음. swap2,swap3는 원본수정됨.

```C++
void swap1(int a,int b)
{
    int tmp = a;
    a = b;
    b = tmp;
}
```

```C++
void swap2(int* a,int* b)
{
    int tmp = *a;
    *a = *b;
    *b = tmp;
}
```

```C++
void swap3(int& a,int& b)
{
    int tmp = a;
    a = b;
    b = tmp;
}
```

## STL - vector

```C++
vector<int> v(100);
v[20]=10;
v[60]=-4;
```

### STL을 함수인자로넘길때

```C++
void func1(vector<int> v)
{
    v[10]=7;
}
int main(void)
{
    vector<int> v(100);
    func1(v);
    cout << v[10];// 0
}
```

- func1로 인자로보낼때 복사를 해서 보내기때문에, 원본에 영향을 주지않음.

```C++
bool cmp1(vector<int> v1, vector<int> v2, int idx)
{
    return v1[idx] > v2[idx];
}
bool cmp2(vector<int>& v1, vector<int>& v2, int idx)
{
    return v1[idx] > v2[idx];
}
```

- cmp1는 vector의 크기가 N일떄 O(N) 시간복잡도를 가진다. 복사를 하기때문.
- cmp2가 의도한대로 O(1)이 됨.

### 빠른입출력

입출력 속도때문에, 시간초과나는 경우가 있음.

#### ios::sync_with_stdio(false);

c에서 쓰는 printf,scanf와 c++에서 쓰는 cin,cout는 스트림이 분리되어있음.  
코드의 흐름과, 실제출력이 동일하게 동기화 하고있는데, 이를 끊어서 시간을 절약.  
동기화를 끊었으면, 두 스트림을 섞어사용하면 안됨.  
ios::sync_with_stdio(false);인데 타이핑 아낄겸 ios::sync_with_stdio(0);으로 사용.

#### cin.tie(0);

기본적으로, cin 명령을 수행하기전에 cout 버퍼를 비워줌. (입출력 순서를 맞추기위해)  
하지만, 채점서버에서는 상관없이 정답처리됨.  
그래서 cin 명령을 수행하기전에 cout 버퍼를 비우지않도록하는 코드가 cin.tie(nullptr)인데, 타이핑 아낄꼄 cin.tie(0);

### endl 쓰지마세요.

endl은 개행문자를 출력하고, 출력버퍼를 비우라는 명령이다.  
중간중간 버퍼를 비울필요가 없음. 개행문자를 사용하자.

### 출력 마지막의 공백, 줄바꿈은 상관없다.

이부분을 위한 별도의 예외처리를 할필요가 없다. 똑같이 정답으로 처리된다.

### 디버거는 굳이 사용하지않는걸 권장.

단순히 변수출력을 해서, 디버깅.

# 0x03 배열

## 배열의 성질

1 O(1)에 k번째 원소를 확인/변경가능
2 메모리 오버헤드가 거의없음
3 cache hit rate가 높음
4 메모리상 연속구간을 잡아야해서 할당에 제약이 걸림

## 기능별 시간복잡도

맨뒤에 추가/삭제 O(1)  
중간에 추가/삭제 O(N)  
조회는 O(1)

정확히는 메소드별, 시간복잡도를 생각해야함.

## 배열 직접구현코드

<details>
<summary>펼치기</summary>

```C++
#include <bits/stdc++.h>
using namespace std;

void insert(int idx, int num, int arr[], int& len){
  for(int i = len; i > idx; i--)
    arr[i] = arr[i-1];
  arr[idx] = num;
  len++;
}

void erase(int idx, int arr[], int& len){
  len--;
  for(int i = idx; i < len; i++)
    arr[i] = arr[i+1];
}

void printArr(int arr[], int& len){
  for(int i = 0; i < len; i++) cout << arr[i] << ' ';
  cout << "\n\n";
}

void insert_test(){
  cout << "***** insert_test *****\n";
  int arr[10] = {10, 20, 30};
  int len = 3;
  insert(3, 40, arr, len); // 10 20 30 40
  printArr(arr, len);
  insert(1, 50, arr, len); // 10 50 20 30 40
  printArr(arr, len);
  insert(0, 15, arr, len); // 15 10 50 20 30 40
  printArr(arr, len);
}

void erase_test(){
  cout << "***** erase_test *****\n";
  int arr[10] = {10, 50, 40, 30, 70, 20};
  int len = 6;
  erase(4, arr, len); // 10 50 40 30 20
  printArr(arr, len);
  erase(1, arr, len); // 10 40 30 20
  printArr(arr, len);
  erase(3, arr, len); // 10 40 30
  printArr(arr, len);
}

int main(void) {
  insert_test();
  erase_test();
}
```

</details>

## 배열의 초기화 팁

3번째방법인 fill함수를 권장.

```c++
int a[21];
int b[21][21];

//1번째. memset
memset(a,0,sizeof a);
memset(b,0, sizeof b);


//2번째. for방법
for(int i=0;i<21;i++)
{
    a[i]=0;
}
for(int i=0;i<21;i++)
{
    for(int j=0;j<21;j++)
    {
        b[i][j]=0;
    }
}

//3번째. fill
fill(a,a+21,0);
for(int i=0;i<21;i++)
{
    fill(b[i],b[i]+21,0);
}
```

## STL vector

그래프의 인접리스트를 저장할때 vector가 유용하지만, 그전까지는 배열로 커버가능.  
[vector래퍼사이트](https://cplusplus.com/reference/vector/vector/)

간단하게 vector 예제코드

```C++
#include <bits/stdc++.h>
using namespace std;

int main(void) {
  vector<int> v1(3, 5); // {5,5,5};
  cout << v1.size() << '\n'; // 3
  v1.push_back(7); // {5,5,5,7};

  vector<int> v2(2); // {0,0};
  v2.insert(v2.begin()+1, 3); // {0,3,0};

  vector<int> v3 = {1,2,3,4}; // {1,2,3,4}
  v3.erase(v3.begin()+2); // {1,2,4};

  vector<int> v4; // {}
  v4 = v3; // {1,2,4} ---deep copy:v4가 바껴도 v3에 영향주지않음.
  cout << v4[0] << v4[1] << v4[2] << '\n';
  v4.pop_back(); // {1,2}
  v4.clear(); // {}
}
```

## 순회

size()-1사용시 유의.

```C++
vector<int> v1 = {1,2,3,4,5,6};

for(int e: v1)
    cout << e << ' ';
for(int& e: v1)//원본이 들어감.
    cout << e << ' ';
for(int i=0;i<v1.size();i++)
    cout << v1[i] << ' ';
for(int i=0;i<=v1.size()-1;i++) //size()함수는 unsigned int를 반환하는데, 크기가0일때 -1해버리면, 4294967295가 됨.
    cout << v1[i]<<' ';
```

## if(1)

값이 0이면 false, 0이아니면 true.

# 0x04 연결리스트

## 특징

k번째 원소를 확인/변경하기위해 O(k)가 필요함.  
k번째 원소를 추가/삭제는 O(1).  
메모리상 연속하지않아, cache hit rate가 낮지만 할당이 다소 쉬움.
임의위치에 추가/삭제가 많다면, 연결리스트를 고려해보는것이 좋음.

## 종류

단일연결리스트:다음원소
이중연결리스트: 이전원소, 다음원소
원형연결리스트: 맨마지막원소의 다음원소가 첫원소가 됨.

## 배열 vs 리스트

배열과 리스트는 선형 자료구조.  
트리 그래프는 비선형 자료구조.

## STL list

내부구현이 이중연결리스트로 구현이 되어있다.

```c++
#include <bits/stdc++.h>
using namespace std;

int main(void) {
  list<int> L = {1,2}; // 1 2
  list<int>::iterator t = L.begin(); // t는 1을 가리키는 중
  L.push_front(10); // 10 1 2
  cout << *t << '\n'; // t가 가리키는 값 = 1을 출력
  L.push_back(5); // 10 1 2 5
  L.insert(t, 6); // t가 가리키는 곳 앞에 6을 삽입, 10 6 1 2 5
  t++; // t를 1칸 앞으로 전진, 현재 t가 가리키는 값은 2
  t = L.erase(t); // t가 가리키는 값을 제거, 그 다음 원소인 5의 위치를 반환
                  // 10 6 1 5, t가 가리키는 값은 5
  cout << *t << '\n'; // 5
  for(auto i : L) cout << i << ' ';
  cout << '\n';
  for(list<int>::iterator it = L.begin(); it != L.end(); it++)
    cout << *it << ' ';
}
```

## 야매 연결리스트구현코드

```c++
#include <bits/stdc++.h>
using namespace std;

const int MX = 1000005;
int dat[MX], pre[MX], nxt[MX];
int unused = 1;

void insert(int addr, int num){
  dat[unused] = num;
  pre[unused] = addr;
  nxt[unused] = nxt[addr];
  if(nxt[addr] != -1) pre[nxt[addr]] = unused;
  nxt[addr] = unused;
  unused++;
}

void erase(int addr){
  nxt[pre[addr]] = nxt[addr];
  if(nxt[addr] != -1) pre[nxt[addr]] = pre[addr];
}

void traverse(){
  int cur = nxt[0];
  while(cur != -1){
    cout << dat[cur] << ' ';
    cur = nxt[cur];
  }
  cout << "\n\n";
}

void insert_test(){
  cout << "****** insert_test *****\n";
  insert(0, 10); // 10(address=1)
  traverse();
  insert(0, 30); // 30(address=2) 10
  traverse();
  insert(2, 40); // 30 40(address=3) 10
  traverse();
  insert(1, 20); // 30 40 10 20(address=4)
  traverse();
  insert(4, 70); // 30 40 10 20 70(address=5)
  traverse();
}

void erase_test(){
  cout << "****** erase_test *****\n";
  erase(1); // 30 40 20 70
  traverse();
  erase(2); // 40 20 70
  traverse();
  erase(4); // 40 70
  traverse();
  erase(5); // 40
  traverse();
}

int main(void) {
  fill(pre, pre+MX, -1);
  fill(nxt, nxt+MX, -1);
  insert_test();
  erase_test();
}
```

# 0x05 스택

## 특징

원소 추가/제거 O(1)
제일 상단의 원소확인 O(1)

## 배열로 스택을 구현

```C++
#include <bits/stdc++.h>
using namespace std;

const int MX = 1000005;
int dat[MX];
int pos = 0;

void push(int x){
  dat[pos++] = x;
}

void pop(){
  pos--;
}

int top(){
  return dat[pos-1];
}

void test(){
  push(5); push(4); push(3);
  cout << top() << '\n'; // 3
  pop(); pop();
  cout << top() << '\n'; // 5
  push(10); push(12);
  cout << top() << '\n'; // 12
  pop();
  cout << top() << '\n'; // 10
}

int main(void) {
	test();
}
```

## STL stack

```C++
#include <bits/stdc++.h>
using namespace std;

int main(void) {
  stack<int> S;
  S.push(10); // 10
  S.push(20); // 10 20
  S.push(30); // 10 20 30
  cout << S.size() << '\n'; // 3
  if(S.empty()) cout << "S is empty\n";
  else cout << "S is not empty\n"; // S is not empty
  S.pop(); // 10 20
  cout << S.top() << '\n'; // 20
  S.pop(); // 10
  cout << S.top() << '\n'; // 10
  S.pop(); // empty
  if(S.empty()) cout << "S is empty\n"; // S is empty
  cout << S.top() << '\n'; // runtime error 발생
}
```

스택이 비어있을때, pop()이나 top()을 호출하면, 런타임에러가 발생.

# 0x06 큐

[cpp큐 래퍼런스](https://cplusplus.com/reference/queue/queue/)  
보통 큐는 BFS랑, Flood Fill할때 쓰게되는데, 둘다 코테 단골문제.  
스택과 마찬가지로, 큐가 비어있을때 front나 back나 pop을 호출하면, 런타임에러가 발생.

## 특징

- FIFO(first in first out)
- 원소의 추가/제거 O(1).
- 제일 앞/뒤의 원소확인이 O(1)
- rear: 추가되는쪽. 뒤쪽.
- front: 제거되는쪽. 앞쪽.

## 배열로 큐를 구현

```c++
#include <bits/stdc++.h>
using namespace std;

const int MX = 1000005;
int dat[MX];
int head = 0, tail = 0;

void push(int x){
  dat[tail++] = x;
}

void pop(){
  head++;
}

int front(){
  return dat[head];
}

int back(){
  return dat[tail-1];
}

void test(){
  push(10); push(20); push(30);
  cout << front() << '\n'; // 10
  cout << back() << '\n'; // 30
  pop(); pop();
  push(15); push(25);
  cout << front() << '\n'; // 30
  cout << back() << '\n'; // 25
}

int main(void) {
  test();
}
```

## STL queue

```C++
#include <bits/stdc++.h>
using namespace std;

int main(void) {
  queue<int> Q;
  Q.push(10); // 10
  Q.push(20); // 10 20
  Q.push(30); // 10 20 30
  cout << Q.size() << '\n'; // 3
  if(Q.empty()) cout << "Q is empty\n";
  else cout << "Q is not empty\n"; // Q is not empty
  Q.pop(); // 20 30
  cout << Q.front() << '\n'; // 20
  cout << Q.back() << '\n'; // 30
  Q.push(40); // 20 30 40
  Q.pop(); // 30 40
  cout << Q.front() << '\n'; // 30
}
```

# 0x07 덱

## 특징

deque: double ended Queue
양쪽끝에서 삽입과 삭제가 가능.

## 배열로 덱을 구현

배열의 인덱스중앙에서, head, tail을 놓고, 좌우로 확장하는 모습.

```C++
#include <bits/stdc++.h>
using namespace std;

const int MX = 1000005;
int dat[2*MX+1];
int head = MX, tail = MX;

void push_front(int x){
  dat[--head] = x;
}

void push_back(int x){
  dat[tail++] = x;
}

void pop_front(){
  head++;
}

void pop_back(){
  tail--;
}

int front(){
  return dat[head];
}

int back(){
  return dat[tail-1];
}

void test(){
  push_back(30); // 30
  cout << front() << '\n'; // 30
  cout << back() << '\n'; // 30
  push_front(25); // 25 30
  push_back(12); // 25 30 12
  cout << back() << '\n'; // 12
  push_back(62); // 25 30 12 62
  pop_front(); // 30 12 62
  cout << front() << '\n'; // 30
  pop_front(); // 12 62
  cout << back() << '\n'; // 62
}

int main(void){
  test();
}
```

## STL deque

```c++
#include <bits/stdc++.h>
using namespace std;

int main(void){
  deque<int> DQ;
  DQ.push_front(10); // 10
  DQ.push_back(50); // 10 50
  DQ.push_front(24); // 24 10 50
  for(auto x : DQ) cout << x << ' ';
  cout << DQ.size() << '\n'; // 3
  if(DQ.empty()) cout << "DQ is empty\n";
  else cout << "DQ is not empty\n"; // DQ is not empty
  DQ.pop_front(); // 10 50
  DQ.pop_back(); // 10
  cout << DQ.back() << '\n'; // 10
  DQ.push_back(72); // 10 72
  cout << DQ.front() << '\n'; // 10
  DQ.push_back(12); // 10 72 12
  DQ[2] = 17; // 10 72 17
  DQ.insert(DQ.begin()+1, 33); // 10 33 72 17
  DQ.insert(DQ.begin()+4, 60); // 10 33 72 17 60
  for(auto x : DQ) cout << x << ' ';
  cout << '\n';
  DQ.erase(DQ.begin()+3); // 10 33 72 60
  cout << DQ[3] << '\n'; // 60
  DQ.clear(); // DQ의 모든 원소 제거
}
```

STL deque은 매우 독특하게도 double ended queue라는 느낌보다는 vector랑 비슷한데 front에서도 O(1)에 추가와 제거가 가능한 느낌이 강합니다.  
insert, erase, 인덱스접근 또한 가능합니다. 심지어 front에서 추가/제거가 O(1) 가능합니다.
vector는 모든 원소들이 메모리상에 연속하게 배치되어 있지만, dequeue는 연속배치가 아닙니다.

설명참고: [vector vs deque](https://cplusplus.com/reference/deque/deque/)

# 0x08 스택의활용(수식의 괄호쌍)

## 올바른 괄호쌍 판별법

1. 여는 괄호가 나오면 스택에 추가.
2. 닫는 괄호가 나왔을 경우,  
   2.1. 스택이 비어있으면 올바르지 않은 괄호 쌍.  
   2.2. 스택의 top이 짝이 맞지않는 괄호일경우 올바르지않은 괄호쌍.  
   2.3. 스택의 top이 짝이 맞는 괄호일경우 pop.
3. 모든 과정을 끝낸후 스택에 괄호가 남아있으면, 올바르지않은 괄호쌍. 남아있지않으면 올바른 괄호쌍.

# 0x09 BFS

# 0x0A DFS

# 0x0B 재귀

# 0x0C 백트레킹

# 0x0D 시뮬레이션
