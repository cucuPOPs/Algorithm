[Back(메인으로)](/README.md)

# 0x00 오리엔테이션

강의에서는 C++로된 코드만 제공함.  
문제를 많이 풀어봐야함.  
맞은문제도 다른사람 코드를 보고, 좋은코드는 흡수하면서, 최적화된 코딩스타일을 계속 구축해가는게 좋음.  
`#include<bits/stdc++.h>` 왠만한 헤더들을 합쳐놓은 헤더.  
바킹독 본인은 visual code를 사용함.

# 0x01 기초코드작성요령1

빅오표기법, 시간복잡도, 공간복잡도.

## 정수자료형

- 범위를 넘어서게될때 오버플로우는, 에러를 띄우지않아서, 유의해서 사용.

| 자료형    | 크기         | 범위                                                   | 설명                            |
| --------- | ------------ | ------------------------------------------------------ | ------------------------------- |
| char      | 1byte = 8bit | 0 ~ 255                                                |                                 |
| short     | 2byte        | -32,768 ~ 32,767                                       |                                 |
| int       | 4byte        | -2,147,483,648 ~ 2,147,483,647                         |                                 |
| long long | 8byte        | -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 | int범위를 넘어설때 longlong사용 |

## 실수자료형

- 실수의 저장/연산과정에서 반드시 오차가 발생할수밖에 없다.
- 과학적표기법을 따름. exponent=지수부분, fraction=유효숫자부분
- 알고리즘문제에서는 double 대신 float를 써야하는경우는 전혀없음. -> 실수를 사용해야한다면 double!
- ll을 double에 담으면, 오차발생가능.
- int를 double에 담으면, 오차발생X.
- 실수비교떄는 등호사용X. 대략,,`if(abs(a-b) < 1e-12)`이면 동일처리하면 안전.

  | 자료형 | 크기  | 범위                                | 설명            |
  | ------ | ----- | ----------------------------------- | --------------- |
  | float  | 4byte | sign(1), exponent(8), fraction(23)  | 유효숫자 6자리  |
  | double | 8byte | sign(1), exponent(11), fraction(52) | 유효숫자 15자리 |

# 0x02 기초코드작성요령2

swap1은 원본수정하지않음. swap2,swap3는 원본수정됨.

```C++
void swap1(int a,int b)
{
    int tmp = a;
    a = b;
    b = tmp;
}
```

```C++
void swap2(int* a,int* b)
{
    int tmp = *a;
    *a = *b;
    *b = tmp;
}
```

```C++
void swap3(int& a,int& b)
{
    int tmp = a;
    a = b;
    b = tmp;
}
```

## STL - vector

```C++
vector<int> v(100);
v[20]=10;
v[60]=-4;
```

### STL을 함수인자로넘길때

```C++
void func1(vector<int> v)
{
    v[10]=7;
}
int main(void)
{
    vector<int> v(100);
    func1(v);
    cout << v[10];// 0
}
```

- func1로 인자로보낼때 복사를 해서 보내기때문에, 원본에 영향을 주지않음.

```C++
bool cmp1(vector<int> v1, vector<int> v2, int idx)
{
    return v1[idx] > v2[idx];
}
bool cmp2(vector<int>& v1, vector<int>& v2, int idx)
{
    return v1[idx] > v2[idx];
}
```

- cmp1는 vector의 크기가 N일떄 O(N) 시간복잡도를 가진다. 복사를 하기때문.
- cmp2가 의도한대로 O(1)이 됨.

### 빠른입출력

입출력 속도때문에, 시간초과나는 경우가 있음.

#### ios::sync_with_stdio(false);

c에서 쓰는 printf,scanf와 c++에서 쓰는 cin,cout는 스트림이 분리되어있음.  
코드의 흐름과, 실제출력이 동일하게 동기화 하고있는데, 이를 끊어서 시간을 절약.  
동기화를 끊었으면, 두 스트림을 섞어사용하면 안됨.  
ios::sync_with_stdio(false);인데 타이핑 아낄겸 ios::sync_with_stdio(0);으로 사용.

#### cin.tie(0);

기본적으로, cin 명령을 수행하기전에 cout 버퍼를 비워줌. (입출력 순서를 맞추기위해)  
하지만, 채점서버에서는 상관없이 정답처리됨.  
그래서 cin 명령을 수행하기전에 cout 버퍼를 비우지않도록하는 코드가 cin.tie(nullptr)인데, 타이핑 아낄꼄 cin.tie(0);

### endl 쓰지마세요.

endl은 개행문자를 출력하고, 출력버퍼를 비우라는 명령이다.  
중간중간 버퍼를 비울필요가 없음. 개행문자를 사용하자.

### 출력 마지막의 공백, 줄바꿈은 상관없다.

이부분을 위한 별도의 예외처리를 할필요가 없다. 똑같이 정답으로 처리된다.

### 디버거는 굳이 사용하지않는걸 권장.

단순히 변수출력을 해서, 디버깅.

# 0x03 배열

## 배열의 성질

1 O(1)에 k번째 원소를 확인/변경가능
2 메모리 오버헤드가 거의없음
3 cache hit rate가 높음
4 메모리상 연속구간을 잡아야해서 할당에 제약이 걸림

## 기능별 시간복잡도

맨뒤에 추가/삭제 O(1)  
중간에 추가/삭제 O(N)  
조회는 O(1)

정확히는 메소드별, 시간복잡도를 생각해야함.

## 배열 직접구현코드

<details>
<summary>펼치기</summary>

```C++
#include <bits/stdc++.h>
using namespace std;

void insert(int idx, int num, int arr[], int& len){
  for(int i = len; i > idx; i--)
    arr[i] = arr[i-1];
  arr[idx] = num;
  len++;
}

void erase(int idx, int arr[], int& len){
  len--;
  for(int i = idx; i < len; i++)
    arr[i] = arr[i+1];
}

void printArr(int arr[], int& len){
  for(int i = 0; i < len; i++) cout << arr[i] << ' ';
  cout << "\n\n";
}

void insert_test(){
  cout << "***** insert_test *****\n";
  int arr[10] = {10, 20, 30};
  int len = 3;
  insert(3, 40, arr, len); // 10 20 30 40
  printArr(arr, len);
  insert(1, 50, arr, len); // 10 50 20 30 40
  printArr(arr, len);
  insert(0, 15, arr, len); // 15 10 50 20 30 40
  printArr(arr, len);
}

void erase_test(){
  cout << "***** erase_test *****\n";
  int arr[10] = {10, 50, 40, 30, 70, 20};
  int len = 6;
  erase(4, arr, len); // 10 50 40 30 20
  printArr(arr, len);
  erase(1, arr, len); // 10 40 30 20
  printArr(arr, len);
  erase(3, arr, len); // 10 40 30
  printArr(arr, len);
}

int main(void) {
  insert_test();
  erase_test();
}
```

</details>

## 배열의 초기화 팁

3번째방법인 fill함수를 권장.

```c++
int a[21];
int b[21][21];

//1번째. memset
memset(a,0,sizeof a);
memset(b,0, sizeof b);


//2번째. for방법
for(int i=0;i<21;i++)
{
    a[i]=0;
}
for(int i=0;i<21;i++)
{
    for(int j=0;j<21;j++)
    {
        b[i][j]=0;
    }
}

//3번째. fill
fill(a,a+21,0);
for(int i=0;i<21;i++)
{
    fill(b[i],b[i]+21,0);
}
```

## STL vector

그래프의 인접리스트를 저장할때 vector가 유용하지만, 그전까지는 배열로 커버가능.  
[vector래퍼사이트](https://cplusplus.com/reference/vector/vector/)

간단하게 vector 예제코드

```C++
#include <bits/stdc++.h>
using namespace std;

int main(void) {
  vector<int> v1(3, 5); // {5,5,5};
  cout << v1.size() << '\n'; // 3
  v1.push_back(7); // {5,5,5,7};

  vector<int> v2(2); // {0,0};
  v2.insert(v2.begin()+1, 3); // {0,3,0};

  vector<int> v3 = {1,2,3,4}; // {1,2,3,4}
  v3.erase(v3.begin()+2); // {1,2,4};

  vector<int> v4; // {}
  v4 = v3; // {1,2,4} ---deep copy:v4가 바껴도 v3에 영향주지않음.
  cout << v4[0] << v4[1] << v4[2] << '\n';
  v4.pop_back(); // {1,2}
  v4.clear(); // {}
}
```

## 순회

size()-1사용시 유의.

```C++
vector<int> v1 = {1,2,3,4,5,6};

for(int e: v1)
    cout << e << ' ';
for(int& e: v1)//원본이 들어감.
    cout << e << ' ';
for(int i=0;i<v1.size();i++)
    cout << v1[i] << ' ';
for(int i=0;i<=v1.size()-1;i++) //size()함수는 unsigned int를 반환하는데, 크기가0일때 -1해버리면, 4294967295가 됨.
    cout << v1[i]<<' ';
```

## if(1)

값이 0이면 false, 0이아니면 true.

# 0x04 연결리스트

## 특징

k번째 원소를 확인/변경하기위해 O(k)가 필요함.  
k번째 원소를 추가/삭제는 O(1).  
메모리상 연속하지않아, cache hit rate가 낮지만 할당이 다소 쉬움.
임의위치에 추가/삭제가 많다면, 연결리스트를 고려해보는것이 좋음.

## 종류

단일연결리스트:다음원소
이중연결리스트: 이전원소, 다음원소
원형연결리스트: 맨마지막원소의 다음원소가 첫원소가 됨.

## 배열 vs 리스트

배열과 리스트는 선형 자료구조.  
트리 그래프는 비선형 자료구조.

## STL list

내부구현이 이중연결리스트로 구현이 되어있다.

```c++
#include <bits/stdc++.h>
using namespace std;

int main(void) {
  list<int> L = {1,2}; // 1 2
  list<int>::iterator t = L.begin(); // t는 1을 가리키는 중
  L.push_front(10); // 10 1 2
  cout << *t << '\n'; // t가 가리키는 값 = 1을 출력
  L.push_back(5); // 10 1 2 5
  L.insert(t, 6); // t가 가리키는 곳 앞에 6을 삽입, 10 6 1 2 5
  t++; // t를 1칸 앞으로 전진, 현재 t가 가리키는 값은 2
  t = L.erase(t); // t가 가리키는 값을 제거, 그 다음 원소인 5의 위치를 반환
                  // 10 6 1 5, t가 가리키는 값은 5
  cout << *t << '\n'; // 5
  for(auto i : L) cout << i << ' ';
  cout << '\n';
  for(list<int>::iterator it = L.begin(); it != L.end(); it++)
    cout << *it << ' ';
}
```

## 야매 연결리스트구현코드

```c++
#include <bits/stdc++.h>
using namespace std;

const int MX = 1000005;
int dat[MX], pre[MX], nxt[MX];
int unused = 1;

void insert(int addr, int num){
  dat[unused] = num;
  pre[unused] = addr;
  nxt[unused] = nxt[addr];
  if(nxt[addr] != -1) pre[nxt[addr]] = unused;
  nxt[addr] = unused;
  unused++;
}

void erase(int addr){
  nxt[pre[addr]] = nxt[addr];
  if(nxt[addr] != -1) pre[nxt[addr]] = pre[addr];
}

void traverse(){
  int cur = nxt[0];
  while(cur != -1){
    cout << dat[cur] << ' ';
    cur = nxt[cur];
  }
  cout << "\n\n";
}

void insert_test(){
  cout << "****** insert_test *****\n";
  insert(0, 10); // 10(address=1)
  traverse();
  insert(0, 30); // 30(address=2) 10
  traverse();
  insert(2, 40); // 30 40(address=3) 10
  traverse();
  insert(1, 20); // 30 40 10 20(address=4)
  traverse();
  insert(4, 70); // 30 40 10 20 70(address=5)
  traverse();
}

void erase_test(){
  cout << "****** erase_test *****\n";
  erase(1); // 30 40 20 70
  traverse();
  erase(2); // 40 20 70
  traverse();
  erase(4); // 40 70
  traverse();
  erase(5); // 40
  traverse();
}

int main(void) {
  fill(pre, pre+MX, -1);
  fill(nxt, nxt+MX, -1);
  insert_test();
  erase_test();
}
```

# 0x05 스택

## 특징

원소 추가/제거 O(1)
제일 상단의 원소확인 O(1)

## 배열로 스택을 구현

```C++
#include <bits/stdc++.h>
using namespace std;

const int MX = 1000005;
int dat[MX];
int pos = 0;

void push(int x){
  dat[pos++] = x;
}

void pop(){
  pos--;
}

int top(){
  return dat[pos-1];
}

void test(){
  push(5); push(4); push(3);
  cout << top() << '\n'; // 3
  pop(); pop();
  cout << top() << '\n'; // 5
  push(10); push(12);
  cout << top() << '\n'; // 12
  pop();
  cout << top() << '\n'; // 10
}

int main(void) {
	test();
}
```

## STL stack

```C++
#include <bits/stdc++.h>
using namespace std;

int main(void) {
  stack<int> S;
  S.push(10); // 10
  S.push(20); // 10 20
  S.push(30); // 10 20 30
  cout << S.size() << '\n'; // 3
  if(S.empty()) cout << "S is empty\n";
  else cout << "S is not empty\n"; // S is not empty
  S.pop(); // 10 20
  cout << S.top() << '\n'; // 20
  S.pop(); // 10
  cout << S.top() << '\n'; // 10
  S.pop(); // empty
  if(S.empty()) cout << "S is empty\n"; // S is empty
  cout << S.top() << '\n'; // runtime error 발생
}
```

스택이 비어있을때, pop()이나 top()을 호출하면, 런타임에러가 발생.

# 0x06 큐

[cpp큐 래퍼런스](https://cplusplus.com/reference/queue/queue/)  
보통 큐는 BFS랑, Flood Fill할때 쓰게되는데, 둘다 코테 단골문제.  
스택과 마찬가지로, 큐가 비어있을때 front나 back나 pop을 호출하면, 런타임에러가 발생.

## 특징

- FIFO(first in first out)
- 원소의 추가/제거 O(1).
- 제일 앞/뒤의 원소확인이 O(1)
- rear: 추가되는쪽. 뒤쪽.
- front: 제거되는쪽. 앞쪽.

## 배열로 큐를 구현

```c++
#include <bits/stdc++.h>
using namespace std;

const int MX = 1000005;
int dat[MX];
int head = 0, tail = 0;

void push(int x){
  dat[tail++] = x;
}

void pop(){
  head++;
}

int front(){
  return dat[head];
}

int back(){
  return dat[tail-1];
}

void test(){
  push(10); push(20); push(30);
  cout << front() << '\n'; // 10
  cout << back() << '\n'; // 30
  pop(); pop();
  push(15); push(25);
  cout << front() << '\n'; // 30
  cout << back() << '\n'; // 25
}

int main(void) {
  test();
}
```

## STL queue

```C++
#include <bits/stdc++.h>
using namespace std;

int main(void) {
  queue<int> Q;
  Q.push(10); // 10
  Q.push(20); // 10 20
  Q.push(30); // 10 20 30
  cout << Q.size() << '\n'; // 3
  if(Q.empty()) cout << "Q is empty\n";
  else cout << "Q is not empty\n"; // Q is not empty
  Q.pop(); // 20 30
  cout << Q.front() << '\n'; // 20
  cout << Q.back() << '\n'; // 30
  Q.push(40); // 20 30 40
  Q.pop(); // 30 40
  cout << Q.front() << '\n'; // 30
}
```

# 0x07 덱

## 특징

deque: double ended Queue
양쪽끝에서 삽입과 삭제가 가능.

## 배열로 덱을 구현

배열의 인덱스중앙에서, head, tail을 놓고, 좌우로 확장하는 모습.

```C++
#include <bits/stdc++.h>
using namespace std;

const int MX = 1000005;
int dat[2*MX+1];
int head = MX, tail = MX;

void push_front(int x){
  dat[--head] = x;
}

void push_back(int x){
  dat[tail++] = x;
}

void pop_front(){
  head++;
}

void pop_back(){
  tail--;
}

int front(){
  return dat[head];
}

int back(){
  return dat[tail-1];
}

void test(){
  push_back(30); // 30
  cout << front() << '\n'; // 30
  cout << back() << '\n'; // 30
  push_front(25); // 25 30
  push_back(12); // 25 30 12
  cout << back() << '\n'; // 12
  push_back(62); // 25 30 12 62
  pop_front(); // 30 12 62
  cout << front() << '\n'; // 30
  pop_front(); // 12 62
  cout << back() << '\n'; // 62
}

int main(void){
  test();
}
```

## STL deque

```c++
#include <bits/stdc++.h>
using namespace std;

int main(void){
  deque<int> DQ;
  DQ.push_front(10); // 10
  DQ.push_back(50); // 10 50
  DQ.push_front(24); // 24 10 50
  for(auto x : DQ) cout << x << ' ';
  cout << DQ.size() << '\n'; // 3
  if(DQ.empty()) cout << "DQ is empty\n";
  else cout << "DQ is not empty\n"; // DQ is not empty
  DQ.pop_front(); // 10 50
  DQ.pop_back(); // 10
  cout << DQ.back() << '\n'; // 10
  DQ.push_back(72); // 10 72
  cout << DQ.front() << '\n'; // 10
  DQ.push_back(12); // 10 72 12
  DQ[2] = 17; // 10 72 17
  DQ.insert(DQ.begin()+1, 33); // 10 33 72 17
  DQ.insert(DQ.begin()+4, 60); // 10 33 72 17 60
  for(auto x : DQ) cout << x << ' ';
  cout << '\n';
  DQ.erase(DQ.begin()+3); // 10 33 72 60
  cout << DQ[3] << '\n'; // 60
  DQ.clear(); // DQ의 모든 원소 제거
}
```

STL deque은 매우 독특하게도 double ended queue라는 느낌보다는 vector랑 비슷한데 front에서도 O(1)에 추가와 제거가 가능한 느낌이 강합니다.  
insert, erase, 인덱스접근 또한 가능합니다. 심지어 front에서 추가/제거가 O(1) 가능합니다.
vector는 모든 원소들이 메모리상에 연속하게 배치되어 있지만, dequeue는 연속배치가 아닙니다.

설명참고: [vector vs deque](https://cplusplus.com/reference/deque/deque/)

# 0x08 스택의활용(수식의 괄호쌍)

## 올바른 괄호쌍 판별법

1. 여는 괄호가 나오면 스택에 추가.
2. 닫는 괄호가 나왔을 경우,  
   2.1. 스택이 비어있으면 올바르지 않은 괄호 쌍.  
   2.2. 스택의 top이 짝이 맞지않는 괄호일경우 올바르지않은 괄호쌍.  
   2.3. 스택의 top이 짝이 맞는 괄호일경우 pop.
3. 모든 과정을 끝낸후 스택에 괄호가 남아있으면, 올바르지않은 괄호쌍. 남아있지않으면 올바른 괄호쌍.

# 0x09 BFS

BFS: Breadth First Search.  
BFS는 그래프라는 자료구조에서 모든노드를 방문하기위한 알고리즘.  
다차원 배열에서 각칸을 방문할때, 너비를 우선으로 방문하는 알고리즘.

1. 시작하는 칸을 큐에넣고 방문했다는 표시를 남김.
2. 큐에서 원소를 꺼내어, 그 칸에 상하좌우로 인접한 칸에 대해 3번을 진행.
3. 해당칸을 이전에 방문했다면, 아무것도 하지않고, 처음으로 방문했다면 방문했다는 표시를 남기고 해당칸을 큐에 삽입.
4. 큐의 빌때까지 2번을 반복.
   모든 칸이 큐에 1번씩 들어가므로 시간복잡도는 칸이 N개일떄 O(N).

## pair

utility헤더에 있는 pair.`pair<int,int> t1 = make_pair(10, 13);`  
두 자료형을 묶어서 가지고 다닐수있음. C++11이상에서는 그냥 중괄호써서 쉽게 해결할수도 있음.  
각각 대소관계가 설정되어있어서, 알아서 앞쪽의 값을 먼저 비교하고, 이후 뒤쪽의 값을 비교함.

## BFS C++ 코드

```C++
#include <bits/stdc++.h>
using namespace std;
#define X first
#define Y second // pair에서 first, second를 줄여서 쓰기 위해서 사용
int board[502][502] =
{{1,1,1,0,1,0,0,0,0,0},
 {1,0,0,0,1,0,0,0,0,0},
 {1,1,1,0,1,0,0,0,0,0},
 {1,1,0,0,1,0,0,0,0,0},
 {0,1,0,0,0,0,0,0,0,0},
 {0,0,0,0,0,0,0,0,0,0},
 {0,0,0,0,0,0,0,0,0,0} }; // 1이 파란 칸, 0이 빨간 칸에 대응
bool vis[502][502]; // 해당 칸을 방문했는지 여부를 저장
int n = 7, m = 10; // n = 행의 수, m = 열의 수
int dx[4] = {1,0,-1,0};
int dy[4] = {0,1,0,-1}; // 상하좌우 네 방향을 의미
int main(void){
  ios::sync_with_stdio(0);
  cin.tie(0);
  queue<pair<int,int> > Q;
  vis[0][0] = 1; // (0, 0)을 방문했다고 명시
  Q.push({0,0}); // 큐에 시작점인 (0, 0)을 삽입.
  while(!Q.empty()){
    pair<int,int> cur = Q.front(); Q.pop();
    cout << '(' << cur.X << ", " << cur.Y << ") -> ";
    for(int dir = 0; dir < 4; dir++){ // 상하좌우 칸을 살펴볼 것이다.
      int nx = cur.X + dx[dir];
      int ny = cur.Y + dy[dir]; // nx, ny에 dir에서 정한 방향의 인접한 칸의 좌표가 들어감
      if(nx < 0 || nx >= n || ny < 0 || ny >= m) continue; // 범위 밖일 경우 넘어감
      if(vis[nx][ny] || board[nx][ny] != 1) continue; // 이미 방문한 칸이거나 파란 칸이 아닐 경우
      vis[nx][ny] = 1; // (nx, ny)를 방문했다고 명시
      Q.push({nx,ny});
    }
  }
}
```

# 0x0A DFS

# 0x0B 재귀

# 0x0C 백트레킹

# 0x0D 시뮬레이션

# 0x0E 정렬I

# 0x0F 정렬 II

# 0x10 다이나믹 프로그래밍

# 0x11 그리디

# 0x12 수학

# 0x13 이분탐색

# 0x14 투포인터

# 0x15 해시

0x07강 덱 이후로 새로운 자료구조.

## 충돌회피전략

- Chaining: 같은 해시값을 가지는 항목들을, 연결리스트를 둬서, 충돌회피를 하는방법.
- Open Addressing: 충돌이 발생하면, 다음슬록을 찾아 넣는방식.
  - Linear Probing: 충돌발생시, 빈칸을 순차탐색하여 넣는방식.
  - Quadratic Probing: 충돌발생시, 다음빈칸을 제곱형태로, 건너뛰어 넣는방식.
  - double Hashing: 충돌발생시, 이동할 칸의수를 새로운해시함수로 계산하는 방식.

## STL

```c++
#include <bits/stdc++.h>
using namespace std;

void unordered_set_example(){
  unordered_set<int> s;
  s.insert(-10); s.insert(100); s.insert(15); // {-10, 100, 15}
  s.insert(-10); // {-10, 100, 15}
  cout << s.erase(100) << '\n'; // {-10, 15}, 1
  cout << s.erase(20) << '\n'; // {-10, 15}, 0
  if(s.find(15) != s.end()) cout << "15 in s\n";
  else cout << "15 not in s\n";
  cout << s.size() << '\n'; // 2
  cout << s.count(50) << '\n'; // 해당값이 있는지없는지..중복을 허용하지않기떄문에, 0or1출력.
  for(auto e : s) cout << e << ' ';
  cout << '\n';
}

void unordered_multiset_example(){
  unordered_multiset<int> ms;
  ms.insert(-10); ms.insert(100); ms.insert(15); // {-10, 100, 15}
  ms.insert(-10); ms.insert(15);// {-10, -10, 100, 15, 15}
  cout << ms.size() << '\n'; // 5
  for(auto e : ms) cout << e << ' ';
  cout << '\n';
  cout << ms.erase(15) << '\n'; // {-10, -10, 100}, 2
  ms.erase(ms.find(-10)); // {-10, 100}
  ms.insert(100); // {-10, 100, 100}
  cout << ms.count(100) << '\n'; // 2
}
//멀티셋은, erase를 주의.

void unordered_map_example(){
  unordered_map<string, int> m;
  m["hi"] = 123;
  m["bkd"] = 1000;
  m["gogo"] = 165; // ("hi", 123), ("bkd", 1000), ("gogo", 165)
  cout << m.size() << '\n'; // 3
  m["hi"] = -7;  // ("hi", -7), ("bkd", 1000), ("gogo", 165)
  if(m.find("hi") != m.end()) cout << "hi in m\n";
  else cout << "hi not in m\n";
  m.erase("bkd"); // ("hi", 123), ("gogo", 165)
  for(auto e : m)
    cout << e.first << ' ' << e.second << '\n';
}

int main(void){
  unordered_set_example();
  unordered_multiset_example();
  unordered_map_example();
}
```

# 0x16 이진검색트리

BST: 왼쪽 자식 < 부모 < 오른쪽 자식 의 규칙을 따름.  
AVL트리, RB트리: 자가 균형 이진 탐색 트리. 삽입/삭제 시 균형 유지.

### 기본 용어

| 용어                         | 설명                                                          |
| ---------------------------- | ------------------------------------------------------------- |
| **노드(Node)**               | 트리의 한 요소. 데이터를 저장하고, 다른 노드와의 관계를 가짐. |
| **루트(Root)**               | 트리의 최상위 노드. 부모가 없음.                              |
| **간선(Edge)**               | 노드 간의 연결선. 부모와 자식 관계를 나타냄.                  |
| **부모(Parent)**             | 다른 노드의 바로 위 계층 노드.                                |
| **자식(Child)**              | 어떤 노드의 바로 아래 계층 노드.                              |
| **형제(Sibling)**            | 같은 부모를 가진 노드들.                                      |
| **리프(Leaf)**               | 자식 노드가 없는 노드. 말단 노드.                             |
| **내부 노드(Internal Node)** | 자식이 있는 노드 (리프가 아닌 노드).                          |
| **서브트리(Subtree)**        | 특정 노드를 루트로 하는 부분 트리.                            |
| **노드의 깊이(Depth)**       | 루트에서 특정 노드까지의 간선 수.                             |
| **노드의 높이(Height)**      | 특정 노드에서 가장 먼 리프까지의 간선 수.                     |
| **트리의 높이**              | 루트 노드의 높이. 즉, 트리에서 가장 깊은 노드까지의 거리.     |
| **레벨(Level)**              | 루트부터의 거리 (루트는 0레벨, 그 자식은 1레벨...).           |
| **차수(Degree)**             | 노드가 가진 자식 노드의 수.                                   |
| **트리의 차수**              | 트리 내에서 가장 높은 차수를 가진 노드의 차수.                |

### 특징

BST는, insert,erase, find, update 모든연산이 O(lg N).  
리스트와 비교해보면, O(N)인 리스트보다 BST가 좋다.  
해시와 비교해보면, 모든연산이 O(1)인 해시와 차이가있다.  
BST는 원소가 크기순으로 정렬되어있다는 차이점이 있다.

### BST에서 가장어려운연산은, Erase

무턱대고 지워버리면, 트리구조가 깨져버림.

#### case1. 자식이 없는 정점을 지울때

해당노드를 삭제. BST구조가 유지됨.

#### case 2. 자식이 1개인 정점을 지울때

자식을 지워진노드의 자리에 올리면 됨.

#### case 3. 자식이 2개인 정점을 지울때

오른쪽 서브트리에서 가장 작은 값을 찾아, 그 값을 복사해 넣고, 그 노드는 삭제.

### 자가균형트리

BST에서 최악은 편향된트리가 되어, O(N)이 된다. 이를 보완하기위해 AVL이 만들어졌다.  
AVL과 RB트리가 있는데, RB트리가 구현은 좀더 어렵고, 성능이 조금더 좋다.  
STL의 BST는 RB트리로 구현되어있다.  
set래퍼런스: [링크](https://www.cplusplus.com/reference/set/set)
map래퍼런스: [링크](https://www.cplusplus.com/reference/map/map)

# 0x17 우선순위큐

우선순위큐: pop을 할때 가장먼저 들어온원소가 나오는대신, 우선순위가 가장높은원소가 나오는큐.

1. 원소의 추가가 O(lg N)
2. 우선순위가 가장높은 원소의 확인이 O(1)
3. 우선순위가 가장높은 원소의 제거가 O(lg N)

## 힙이라는 자료구조를 이용.

많은분들이 BST와 헷갈려한다.  
힙에서의 삽입순서는, 왼쪽부터 채운다.  
BST는 편향될수있지만, 힙에서는 늘 균형이 맞게된다.

### 힙의 삽입순서

```markdown
     01
    /  \

02 03
/ \ / \
04 05 06 07
```

### Insert

삽입순서를 따르면서 삽입후, 힙구조가 깨질경우, 부모노드와 swap하여, 구조를 유지.  
계속 부모노드와 비교하기때문에, 비교연산이 O(lg N)인것을 알수있다.

### Fetch

루트노드가 최소값/최대값인것을 확인할수있지만, 3번째로 작은값같은 다음값을 확인하지못함.

### Erase

가장 마지막에 추가된 노드와 자리를 바꾸고, 자식노드와 비교해서, 힙구조를 유지하도록 연산함.  
자리를바꿔서 올라가는값은, 셋중에 가장작은값을 올림.

## 배열로 구현방법

0번지는 사용안함.  
루트노드는 1번지.  
x번지의 왼쪽, 오른쪽자식: 2x, 2x+1.  
x번지의 부모: x/2.  
특히 pop함수는..실수하기 쉽다.

```c++
#include <bits/stdc++.h>
using namespace std;

int heap[100005];
int sz = 0; // heap에 들어있는 원소의 수

void push(int x){
  heap[++sz] = x;
  int idx = sz;
  while(idx != 1){
    int par = idx/2;
    if(heap[par] <= heap[idx]) break;
    swap(heap[par], heap[idx]);
    idx = par;
  }
}

int top(){
  return heap[1];
}

void pop(){
  heap[1] = heap[sz--];
  int idx = 1;
  // 왼쪽 자식의 인덱스(=2*idx)가 size보다 크면 idx는 리프
  while(2*idx <= sz){
    int lc = 2*idx, rc = 2*idx+1; // 왼쪽 자식, 오른쪽 자식
    int min_child = lc; // 두 자식 중 작은 인덱스를 담을 예정
    if(rc <= sz && heap[rc] < heap[lc])
      min_child = rc;
    if(heap[idx] <= heap[min_child]) break;
    swap(heap[idx],heap[min_child]);
    idx = min_child;
  }
}

void test(){
  push(10); push(2); push(5); push(9); // {10, 2, 5, 9}
  cout << top() << '\n'; // 2
  pop(); // {10, 5, 9}
  pop(); // {10, 9}
  cout << top() << '\n'; // 9
  push(5); push(15); // {10, 9, 5, 15}
  cout << top() << '\n'; // 5
  pop(); // {10, 9, 15}
  cout << top() << '\n'; // 9
}

int main(void){
  test();
}
```

## STL 최대힙

`priority_queue<int>`은 기본적으로 최대힙. 최소힙을 사용하려면, `priority_queue<int, vector<int>, greater<int>>`으로 선언.

```c++
#include <bits/stdc++.h>
using namespace std;

int main(void){
  priority_queue<int> pq; // 최대 힙
  // priority_queue<int, vector<int>, greater<int>>로 선언시 최소 힙
  pq.push(10); pq.push(2); pq.push(5); pq.push(9); // {10, 2, 5, 9}
  cout << pq.top() << '\n'; // 10
  pq.pop(); // {2, 5, 9}
  cout << pq.size() << '\n'; // 3
  if(pq.empty()) cout << "PQ is empty\n";
  else cout << "PQ is not empty\n";
  pq.pop(); // {2, 5}
  cout << pq.top() << '\n'; // 5
  pq.push(5); pq.push(15); // {2, 5, 5, 15}
  cout << pq.top() << '\n'; // 15
}
```

### set이 기능도 많고, 시간복잡도도 동일한데..굳이쓸필요 있나??

priority_queue는 set보다 수행속도가 빠르고, 공간도 적게 차지합니다.

# 0x18 그래프

그래프? 정점과 간선으로 이루어진 자료구조.
간선(Edge), 정점(Vertex/Node),
차수(degree): 정점에 대해서 이웃한 정점의 개수가 차수.

네비게이션에서 최단경로찾기와 같은 원소사이의 연결관계를 설정해야하는상황에 유용한 자료구조.

## 무방향그래프, 방향그래프

무방향그래프(UnDirected Graph), 방향그래프(Directed Graph)
outDegree: 해당노드에서 나가는 간선의 개수.
InDegree: 해당노드에서 들어오는 간선의 개수.

## 순환그래프, 비순환그래프

순환그래프(Cyclic Graph), 비순환그래프(Acyclic Graph)
순환그래프(Cyclic Graph): 그래프 안에 사이클이 하나이상 존재.
비순환그래프(Acyclic Graph): 그래프안에 사이클이 존재하지않음.

### 사이클

임의의 한점에서 출발해. 자기자신으로 돌아올수있는 경로를 사이클.

## 완전그래프, 연결그래프

완전그래프(Complete Graph), 연결그래프(Conneted Graph)
완전그래프: 모든 서로 다른 두 정점 쌍이 간선으로 연결된 그래프.
연결그래프: 임의의 두 정점 사이에 경로가 항상 존재하는 그래프.

## 표현법1: 인접행렬

보통 1-indexed로 번호를 붙임.
단순 그래프, 즉 두 정점 사이의 간선이 1개 이하인 그래프라고 할 때 연결된 두 정점에는 1을, 연결되지 않은 두 정점에는 0을 주면 그래프를 표현할 수 있음.
만약, 간선이 3개면 3을쓰고, 4개면 4을쓰는방식으로 해결가능.

### 방향그래프

```c++
int adj_matrix[10][10]={};
int v,e;
cin>>v>>e;
for(int i=0;i<e;i++){
  int u,v;
  cin >> u>>v;
  adj_matrix[u][v]=1;
}
```

```c++
int adj_matrix[10][10]={};
int v,e;
cin>>v>>e;
for(int i=0;i<e;i++){
  int u,v;
  cin >> u>>v;
  adj_matrix[u][v]=1;
  adj_matrix[v][u]=1;
}
```

## 표현법2: 인접리스트

정점이 많고, 간선은 상대적으로 적은상황에.

### 방향그래프

```c++
vector<int> adj[10];
int v,e;
cin>>v>>e;
for(int i=0;i<e;i++){
  int u,v;
  cin >> u >> v;
  adj[u].push_back(v);
}
```

### 무방향그래프

```c++
vector<int> adj[10];
int v,e;
cin>>v>>e;
for(int i=0;i<e;i++){
  int u,v;
  cin >> u >> v;
  adj[u].push_back(v);
  adj[v].push_back(u);
}
```

인접행렬과 인접리스트의 비교.
인접행렬: 두 정점의 연결여부를 자주확인할때. E가 V^2에 가까울때.(Edge가 많을때)
인접리스트: 특정정점의 연결된 모든정점을 자주확인할때. E가 V^2보다 훨씬 작을때.

## 그래프의 BFS

1. 시작하는 정점을 큐에 넣고 방문했다는 표시를 남김
2. 큐에서 정점을 꺼내어 그 정점과 연결된 모든 정점들에 대해 3번을 진행
3. 해당 정점을 이전에 방문했다면 아무것도 하지 않고, 처음으로 방문했다면
   방문했다는 표시를 남기고 해당 간을 큐에 삽입
4. 큐가 빌때까지 2번을 반복
   모든 정점이 큐에 최대 1번씩 들어가므로 인접 리스트에서 O(V+E), 인접 행렬에서
   O(v^2)의 시간복잡도.

### BFS 순회 예시코드

```c++
vector<int> adj[10];
bool vis[10];
void bfs(){
  queue<int> q;
  q.push(1);
  vis[1]=true;
  while(!q.empty()){
    int cur=q.front();
    q.pop();
    cout<< cur<< ' ';
    for(auto nxt : adj[cur]){
      if(vis[nxt]) continue;
      q.push(nxt);
      vis[nxt]=true;
    }
  }
}
```

### BFS 거리 예시코드

```c++
vector<int> adj[10];
int dist[10];
void bfs(){
  fill(dist,dist+10,-1);
  queue<int> q;
  q.push(1);
  dist[1]=0;
  while(!q.empty()){
    int cur = q.front();
    q.pop();
    for(auto nxt: adj[i]){
      if(dist[nxt]!=-1) continue;
      q.push(nxt);
      dist[nxt]=dist[cur]+1;
    }
  }
}
```

### BFS 연결그래프가 아닐때 순회

```c++
vector<int> adj[10];
bool vis[10];
int v=9;
void bfs(){
  queue<int> q;
  for(int i=1;i<=v;i++){
    if(vis[i]) continue;
    q.push(i);
    vis[i]=true;
    while(!q.empty()){
      int cur=q.front();
      q.pop();
      cout << cur << ' ';
      for(auto nxt : adj[cur]){
        if(vis[nxt]) continue;
        q.push(nxt);
        vis[nxt]=true;
      }
    }
  }
}
```

### DFS에서 순회(비재귀)

```c++
vector<int> adj[10];
bool vis[10];
void dfs(){
  stack<int> q;
  q.push(1);
  vis[1]=true;
  while(!q.empty()){
    int cur=q.top();
    q.pop();
    cout<< cur<< ' ';
    for(auto nxt : adj[cur]){
      if(vis[nxt]) continue;
      q.push(nxt);
      vis[nxt]=true;
    }
  }
}
```

### DFS에서, 순회(재귀)

스택메모리제한이 작게 설정된곳에서는 재귀대신 스택을 써서 ,DFS순회.

```c++
vector<int> adj[10];
bool vis[10];
void dfs(int cur){
  vis[cur]=true;
  cout << cur << ' ';
  for(auto nxt: adj[cur]){
    if(vis[nxt])continue;
    dfs(nxt);
  }
}
```

### DFS 비재귀(재귀와 같은방문순서로)

앞서본 비재귀코드는, 관념적으로 생각하는 DFS방문순서와 다르게방문함.  
관념적 DFS 방문순서에 맞는 코드.

```c++
vector<int> adj[10];
bool vis[10];
void dfs(){
  stack<int> s;
  s.push(1);
  while(!s.empty()){
    int cur=s.top();
    s.pop();
    if(vis[cur])continue;
    vis[cur]=true;
    cout<< cur << ' ';
    for(auto nxt : adj[cur]){
      if(vis[nxt])continue;
      s.push(nxt);
    }
  }
}
```

# 0x19 트리

트리: 무방향이면서 사이클이 없는 연결그래프.

## BFS예시코드 - 부모배열 채우기

vis배열을 들고갈필요없이, 부모가 누구인지만 저장하고있으면 됨.
p배열: 각정점의 부모번호를 저장할 배열. 이때 루트의 부모는 0.

```c++
vector<int> adj[10];
int p[10];
void bfs(int root){
  queue<int> q;
  q.push(root);
  while(!q.empty()){
    int cur = q.front();
    q.pop();
    cout<< cur << ' ';
    for(int nxt: adj[cur]){
      if(p[cur]==nxt) continue;//부모는 방문했기에 건너뜀.
      q.push(nxt);
      p[nxt]=cur;
    }
  }
}
```

## BFS 예시코드 - 부모와 depth배열 채우기

자식의 depth는 부모depth+1임을 이용.

```c++
vector<int> adj[10];
int p[10];
int depth[10];
void bfs(int root){
  queue<int> q;
  q.push(root);
  while(!q.empty()){
    int cur = q.front();
    q.pop();
    cout<< cur << ' ';
    for(int nxt: adj[cur]){
      if(p[cur]==nxt) continue;//부모는 방문했기에 건너뜀.
      q.push(nxt);
      p[nxt]=cur;
      depth[nxt]=depth[cur]+1;
    }
  }
}
```

## DFS예시코드1 - 부모와 depth배열채우기(비재귀)

```c++
vector<int> adj[10];
int p[10];
int depth[10];
void dfs(int root){
  stack<int> s;
  s.push(root);
  while(!s.empty()){
    int cur=s.top();
    s.pop();
    cout << cur << ' ';
    for(int nxt : adj[cur]){
      if(p[cur]==nxt)continue;
      s.push(nxt);
      p[nxt]=cur;
      depth[nxt]=depth[cur]+1;
    }
  }
}
```

## DFS예시코드2 - 부모와 depth배열채우기(재귀)

```c++
vector<int> adj[10];
int p[10];
int depth[10];
void dfs(int cur){
  cout << cur << ' ';
  for(int nxt : adj[cur]){
    if(p[cur]==nxt)continue;
    p[nxt]=cur;
    depth[nxt]=depth[cur]+1;
    dfs(nxt);
}
```

## DFS예시코드3 - 단순순회,재귀

```c++
vector<int> adj[10];
void dfs(int cur,int par){
  cout << cur << ' ';
  for(int nxt : adj[cur]){
    if(par ==nxt) continue;
    dfs(nxt,cur);
}
```

## 이진트리에서 순회

순회: 레벨/전위/중위/후위.  
adj에넣어서 저장을 할수는있지만,왼쪽자식 오른쪽자식을 구분할수없음.  
lc,rc배열을 구분하여 저장하면 좋음. (leftChild, rightChild).

## 레벨순회

루트를 시작점으로, BFS돌려서 구현가능.

```c++
int lc[9]={0,2,4,6,0,0,0,0,0};
int rc[9]={0,3,5,7,0,8,0,0,0};
void bfs(){//root=1
  queue<int> q;
  q.push(1);
  while(!q.empty()){
    int cur=q.front();
    q.pop();
    cout << cur << ' ';
    if(lc[cur]) q.push(lc[cur]);
    if(rc[cur]) q.push(rc[cur]);
  }
}
```

## 전위순회(PreOrder Traversal)

1. 현재 정점을 방문한다.
2. 완쪽 서브트리를 전위 순회한다.
3. 오른쪽 서브트리를 전위 순회한다.
   전위순회는 DFS와 방문순서가 동일.

```c++
int lc[9]={0,2,4,6,0,0,0,0,0};
int rc[9]={0,3,5,7,0,8,0,0,0};
void preorder(int cur){
  cout<< cur << ' ';
  if(lc[cur]!=0) preorder(lc[cur]);
  if(rc[cur]!=0) preorder(rc[cur]);
}
//preorder(1);
```

## 중위순회(InOrder Traversal)

1. 완쪽 서브트리를 전위 순회한다.
2. 현재 정점을 방문한다.
3. 오른쪽 서브트리를 전위 순회한다.
   만약, 트리가 이진탐색트리였다면, 크기순으로 방문하게됨.

```c++
int lc[9]={0,2,4,6,0,0,0,0,0};
int rc[9]={0,3,5,7,0,8,0,0,0};
void inorder(int cur){
  if(lc[cur]!=0) inorder(lc[cur]);
  cout<< cur << ' ';
  if(rc[cur]!=0) inorder(rc[cur]);
}
//inorder(1);
```

## 후위순회(PostOrder Traversal)

1. 현재 정점을 방문한다.
2. 완쪽 서브트리를 전위 순회한다.
3. 오른쪽 서브트리를 전위 순회한다.

```c++
int lc[9]={0,2,4,6,0,0,0,0,0};
int rc[9]={0,3,5,7,0,8,0,0,0};
void postorder(int cur){
  if(lc[cur]!=0) postorder(lc[cur]);
  if(rc[cur]!=0) postorder(rc[cur]);
  cout<< cur << ' ';
}
//postorder(1);
```

# 0x1A 위상정렬

위상정렬(Topological Sort): 방향그래프에서 간선으로 주어진 정점간 선후관계를 위배하지않도록 나열하는 정렬.

하나의 그래프에는 여러개의 위상정렬결과가 있을수 있음.  
사이클이 존재할경우, 올바른 위상정렬이 존재할수 없음.  
운영체제에서 데드락처럼, inDegree가 0인 조건을 서로 물고물리는 상황이기때문.

## DAG

DAG(Directed Acyclic Graph): 사이클이 존재하지않는 방향그래프.

## 구현

1. 맨 처음 모든 간선을 읽으며 indegree 테이블을 채움
2. indegree가 0인 정점들을 모두 큐에 넣음
3. 큐에서 정점들을 꺼내어 위상 정렬 결과에 추가
4. 해당 정점으로부터 연결된 모든 정점의 indegree 값을 1 감소시킴. 이때 indegree가 0이
   되었다면 그 정점을 큐에 추가
5. 큐가 빌 때 까지 3, 4번 과정을 반복

## 특징

사이클이 있다면, 위상정렬결과에 모든정점이 포함되지않음. -> 사이클판단체크로 활용가능.

n: 정점의개수.
adj: 나에게서 뻗어나가는 정점의 목록이 저장되어있음.
deg: 각 정점의 indegree가 저장되어있음.  

```c++
vector<int> adj[10];
int deg[10];
int n;
queue<int> q;
vector<int> result;
for(int i=1;i<=n;i++){
  if(deg[i]==0) q.push(i);
}
while(!q.empty()){
  int cur=q.front(); q.pop();
  result.push_back(cur);
  for(int nxt: adj[cur]){
    deg[nxt]--;
    if(deg[nxt]==0) q.push(nxt);
  }
}
if(result.size()!=n)
  cout<< "cycle exist";
else{
  for(auto x : result) cout << x << ' ';
}
```

# 0x1B 최소신장트리

# 0x1c 플로이드 알고리즘

# 0x1D 다익스트라 알고리즘

# 0x1E KMP

# 0x1F 트라이

# Appendix_A 문자열기초

# Appendix_B 동적배열

# Appendix_C 비트마스킹

# Appendix_D Union-Find
