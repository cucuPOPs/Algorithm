[Back(ë©”ì¸ìœ¼ë¡œ)](/README.md)

# 0x00 ì˜¤ë¦¬ì—”í…Œì´ì…˜

ê°•ì˜ì—ì„œëŠ” C++ë¡œëœ ì½”ë“œë§Œ ì œê³µí•¨.  
ë¬¸ì œë¥¼ ë§ì´ í’€ì–´ë´ì•¼í•¨.  
ë§ì€ë¬¸ì œë„ ë‹¤ë¥¸ì‚¬ëŒ ì½”ë“œë¥¼ ë³´ê³ , ì¢‹ì€ì½”ë“œëŠ” í¡ìˆ˜í•˜ë©´ì„œ, ìµœì í™”ëœ ì½”ë”©ìŠ¤íƒ€ì¼ì„ ê³„ì† êµ¬ì¶•í•´ê°€ëŠ”ê²Œ ì¢‹ìŒ.  
`#include<bits/stdc++.h>` ì™ ë§Œí•œ í—¤ë”ë“¤ì„ í•©ì³ë†“ì€ í—¤ë”.  
ë°”í‚¹ë… ë³¸ì¸ì€ visual codeë¥¼ ì‚¬ìš©í•¨.

# 0x01 ê¸°ì´ˆì½”ë“œì‘ì„±ìš”ë ¹1

ë¹…ì˜¤í‘œê¸°ë²•, ì‹œê°„ë³µì¡ë„, ê³µê°„ë³µì¡ë„.

## ì •ìˆ˜ìë£Œí˜•

- ë²”ìœ„ë¥¼ ë„˜ì–´ì„œê²Œë ë•Œ ì˜¤ë²„í”Œë¡œìš°ëŠ”, ì—ëŸ¬ë¥¼ ë„ìš°ì§€ì•Šì•„ì„œ, ìœ ì˜í•´ì„œ ì‚¬ìš©.

| ìë£Œí˜•    | í¬ê¸°         | ë²”ìœ„                                                   | ì„¤ëª…                            |
| --------- | ------------ | ------------------------------------------------------ | ------------------------------- |
| char      | 1byte = 8bit | 0 ~ 255                                                |                                 |
| short     | 2byte        | -32,768 ~ 32,767                                       |                                 |
| int       | 4byte        | -2,147,483,648 ~ 2,147,483,647                         |                                 |
| long long | 8byte        | -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 | intë²”ìœ„ë¥¼ ë„˜ì–´ì„¤ë•Œ longlongì‚¬ìš© |

## ì‹¤ìˆ˜ìë£Œí˜•

- ì‹¤ìˆ˜ì˜ ì €ì¥/ì—°ì‚°ê³¼ì •ì—ì„œ ë°˜ë“œì‹œ ì˜¤ì°¨ê°€ ë°œìƒí• ìˆ˜ë°–ì— ì—†ë‹¤.
- ê³¼í•™ì í‘œê¸°ë²•ì„ ë”°ë¦„. exponent=ì§€ìˆ˜ë¶€ë¶„, fraction=ìœ íš¨ìˆ«ìë¶€ë¶„
- ì•Œê³ ë¦¬ì¦˜ë¬¸ì œì—ì„œëŠ” double ëŒ€ì‹  floatë¥¼ ì¨ì•¼í•˜ëŠ”ê²½ìš°ëŠ” ì „í˜€ì—†ìŒ. -> ì‹¤ìˆ˜ë¥¼ ì‚¬ìš©í•´ì•¼í•œë‹¤ë©´ double!
- llì„ doubleì— ë‹´ìœ¼ë©´, ì˜¤ì°¨ë°œìƒê°€ëŠ¥.
- intë¥¼ doubleì— ë‹´ìœ¼ë©´, ì˜¤ì°¨ë°œìƒX.
- ì‹¤ìˆ˜ë¹„êµë–„ëŠ” ë“±í˜¸ì‚¬ìš©X. ëŒ€ëµ,,`if(abs(a-b) < 1e-12)`ì´ë©´ ë™ì¼ì²˜ë¦¬í•˜ë©´ ì•ˆì „.

  | ìë£Œí˜• | í¬ê¸°  | ë²”ìœ„                                | ì„¤ëª…            |
  | ------ | ----- | ----------------------------------- | --------------- |
  | float  | 4byte | sign(1), exponent(8), fraction(23)  | ìœ íš¨ìˆ«ì 6ìë¦¬  |
  | double | 8byte | sign(1), exponent(11), fraction(52) | ìœ íš¨ìˆ«ì 15ìë¦¬ |

# 0x02 ê¸°ì´ˆì½”ë“œì‘ì„±ìš”ë ¹2

swap1ì€ ì›ë³¸ìˆ˜ì •í•˜ì§€ì•ŠìŒ. swap2,swap3ëŠ” ì›ë³¸ìˆ˜ì •ë¨.

```C++
void swap1(int a,int b)
{
    int tmp = a;
    a = b;
    b = tmp;
}
```

```C++
void swap2(int* a,int* b)
{
    int tmp = *a;
    *a = *b;
    *b = tmp;
}
```

```C++
void swap3(int& a,int& b)
{
    int tmp = a;
    a = b;
    b = tmp;
}
```

## STL - vector

```C++
vector<int> v(100);
v[20]=10;
v[60]=-4;
```

### STLì„ í•¨ìˆ˜ì¸ìë¡œë„˜ê¸¸ë•Œ

```C++
void func1(vector<int> v)
{
    v[10]=7;
}
int main(void)
{
    vector<int> v(100);
    func1(v);
    cout << v[10];// 0
}
```

- func1ë¡œ ì¸ìë¡œë³´ë‚¼ë•Œ ë³µì‚¬ë¥¼ í•´ì„œ ë³´ë‚´ê¸°ë•Œë¬¸ì—, ì›ë³¸ì— ì˜í–¥ì„ ì£¼ì§€ì•ŠìŒ.

```C++
bool cmp1(vector<int> v1, vector<int> v2, int idx)
{
    return v1[idx] > v2[idx];
}
bool cmp2(vector<int>& v1, vector<int>& v2, int idx)
{
    return v1[idx] > v2[idx];
}
```

- cmp1ëŠ” vectorì˜ í¬ê¸°ê°€ Nì¼ë–„ O(N) ì‹œê°„ë³µì¡ë„ë¥¼ ê°€ì§„ë‹¤. ë³µì‚¬ë¥¼ í•˜ê¸°ë•Œë¬¸.
- cmp2ê°€ ì˜ë„í•œëŒ€ë¡œ O(1)ì´ ë¨.

### ë¹ ë¥¸ì…ì¶œë ¥

ì…ì¶œë ¥ ì†ë„ë•Œë¬¸ì—, ì‹œê°„ì´ˆê³¼ë‚˜ëŠ” ê²½ìš°ê°€ ìˆìŒ.

#### ios::sync_with_stdio(false);

cì—ì„œ ì“°ëŠ” printf,scanfì™€ c++ì—ì„œ ì“°ëŠ” cin,coutëŠ” ìŠ¤íŠ¸ë¦¼ì´ ë¶„ë¦¬ë˜ì–´ìˆìŒ.  
ì½”ë“œì˜ íë¦„ê³¼, ì‹¤ì œì¶œë ¥ì´ ë™ì¼í•˜ê²Œ ë™ê¸°í™” í•˜ê³ ìˆëŠ”ë°, ì´ë¥¼ ëŠì–´ì„œ ì‹œê°„ì„ ì ˆì•½.  
ë™ê¸°í™”ë¥¼ ëŠì—ˆìœ¼ë©´, ë‘ ìŠ¤íŠ¸ë¦¼ì„ ì„ì–´ì‚¬ìš©í•˜ë©´ ì•ˆë¨.  
ios::sync_with_stdio(false);ì¸ë° íƒ€ì´í•‘ ì•„ë‚„ê²¸ ios::sync_with_stdio(0);ìœ¼ë¡œ ì‚¬ìš©.

#### cin.tie(0);

ê¸°ë³¸ì ìœ¼ë¡œ, cin ëª…ë ¹ì„ ìˆ˜í–‰í•˜ê¸°ì „ì— cout ë²„í¼ë¥¼ ë¹„ì›Œì¤Œ. (ì…ì¶œë ¥ ìˆœì„œë¥¼ ë§ì¶”ê¸°ìœ„í•´)  
í•˜ì§€ë§Œ, ì±„ì ì„œë²„ì—ì„œëŠ” ìƒê´€ì—†ì´ ì •ë‹µì²˜ë¦¬ë¨.  
ê·¸ë˜ì„œ cin ëª…ë ¹ì„ ìˆ˜í–‰í•˜ê¸°ì „ì— cout ë²„í¼ë¥¼ ë¹„ìš°ì§€ì•Šë„ë¡í•˜ëŠ” ì½”ë“œê°€ cin.tie(nullptr)ì¸ë°, íƒ€ì´í•‘ ì•„ë‚„ê¼„ cin.tie(0);

### endl ì“°ì§€ë§ˆì„¸ìš”.

endlì€ ê°œí–‰ë¬¸ìë¥¼ ì¶œë ¥í•˜ê³ , ì¶œë ¥ë²„í¼ë¥¼ ë¹„ìš°ë¼ëŠ” ëª…ë ¹ì´ë‹¤.  
ì¤‘ê°„ì¤‘ê°„ ë²„í¼ë¥¼ ë¹„ìš¸í•„ìš”ê°€ ì—†ìŒ. ê°œí–‰ë¬¸ìë¥¼ ì‚¬ìš©í•˜ì.

### ì¶œë ¥ ë§ˆì§€ë§‰ì˜ ê³µë°±, ì¤„ë°”ê¿ˆì€ ìƒê´€ì—†ë‹¤.

ì´ë¶€ë¶„ì„ ìœ„í•œ ë³„ë„ì˜ ì˜ˆì™¸ì²˜ë¦¬ë¥¼ í• í•„ìš”ê°€ ì—†ë‹¤. ë˜‘ê°™ì´ ì •ë‹µìœ¼ë¡œ ì²˜ë¦¬ëœë‹¤.

### ë””ë²„ê±°ëŠ” êµ³ì´ ì‚¬ìš©í•˜ì§€ì•ŠëŠ”ê±¸ ê¶Œì¥.

ë‹¨ìˆœíˆ ë³€ìˆ˜ì¶œë ¥ì„ í•´ì„œ, ë””ë²„ê¹….

# 0x03 ë°°ì—´

## ë°°ì—´ì˜ ì„±ì§ˆ

1 O(1)ì— kë²ˆì§¸ ì›ì†Œë¥¼ í™•ì¸/ë³€ê²½ê°€ëŠ¥
2 ë©”ëª¨ë¦¬ ì˜¤ë²„í—¤ë“œê°€ ê±°ì˜ì—†ìŒ
3 cache hit rateê°€ ë†’ìŒ
4 ë©”ëª¨ë¦¬ìƒ ì—°ì†êµ¬ê°„ì„ ì¡ì•„ì•¼í•´ì„œ í• ë‹¹ì— ì œì•½ì´ ê±¸ë¦¼

## ê¸°ëŠ¥ë³„ ì‹œê°„ë³µì¡ë„

ë§¨ë’¤ì— ì¶”ê°€/ì‚­ì œ O(1)  
ì¤‘ê°„ì— ì¶”ê°€/ì‚­ì œ O(N)  
ì¡°íšŒëŠ” O(1)

ì •í™•íˆëŠ” ë©”ì†Œë“œë³„, ì‹œê°„ë³µì¡ë„ë¥¼ ìƒê°í•´ì•¼í•¨.

## ë°°ì—´ ì§ì ‘êµ¬í˜„ì½”ë“œ

<details>
<summary>í¼ì¹˜ê¸°</summary>

```C++
#include <bits/stdc++.h>
using namespace std;

void insert(int idx, int num, int arr[], int& len){
  for(int i = len; i > idx; i--)
    arr[i] = arr[i-1];
  arr[idx] = num;
  len++;
}

void erase(int idx, int arr[], int& len){
  len--;
  for(int i = idx; i < len; i++)
    arr[i] = arr[i+1];
}

void printArr(int arr[], int& len){
  for(int i = 0; i < len; i++) cout << arr[i] << ' ';
  cout << "\n\n";
}

void insert_test(){
  cout << "***** insert_test *****\n";
  int arr[10] = {10, 20, 30};
  int len = 3;
  insert(3, 40, arr, len); // 10 20 30 40
  printArr(arr, len);
  insert(1, 50, arr, len); // 10 50 20 30 40
  printArr(arr, len);
  insert(0, 15, arr, len); // 15 10 50 20 30 40
  printArr(arr, len);
}

void erase_test(){
  cout << "***** erase_test *****\n";
  int arr[10] = {10, 50, 40, 30, 70, 20};
  int len = 6;
  erase(4, arr, len); // 10 50 40 30 20
  printArr(arr, len);
  erase(1, arr, len); // 10 40 30 20
  printArr(arr, len);
  erase(3, arr, len); // 10 40 30
  printArr(arr, len);
}

int main(void) {
  insert_test();
  erase_test();
}
```

</details>

## ë°°ì—´ì˜ ì´ˆê¸°í™” íŒ

3ë²ˆì§¸ë°©ë²•ì¸ fillí•¨ìˆ˜ë¥¼ ê¶Œì¥.

```c++
int a[21];
int b[21][21];

//1ë²ˆì§¸. memset
memset(a,0,sizeof a);
memset(b,0, sizeof b);


//2ë²ˆì§¸. forë°©ë²•
for(int i=0;i<21;i++)
{
    a[i]=0;
}
for(int i=0;i<21;i++)
{
    for(int j=0;j<21;j++)
    {
        b[i][j]=0;
    }
}

//3ë²ˆì§¸. fill
fill(a,a+21,0);
for(int i=0;i<21;i++)
{
    fill(b[i],b[i]+21,0);
}
```

## STL vector

ê·¸ë˜í”„ì˜ ì¸ì ‘ë¦¬ìŠ¤íŠ¸ë¥¼ ì €ì¥í• ë•Œ vectorê°€ ìœ ìš©í•˜ì§€ë§Œ, ê·¸ì „ê¹Œì§€ëŠ” ë°°ì—´ë¡œ ì»¤ë²„ê°€ëŠ¥.  
[vectorë˜í¼ì‚¬ì´íŠ¸](https://cplusplus.com/reference/vector/vector/)

ê°„ë‹¨í•˜ê²Œ vector ì˜ˆì œì½”ë“œ

```C++
#include <bits/stdc++.h>
using namespace std;

int main(void) {
  vector<int> v1(3, 5); // {5,5,5};
  cout << v1.size() << '\n'; // 3
  v1.push_back(7); // {5,5,5,7};

  vector<int> v2(2); // {0,0};
  v2.insert(v2.begin()+1, 3); // {0,3,0};

  vector<int> v3 = {1,2,3,4}; // {1,2,3,4}
  v3.erase(v3.begin()+2); // {1,2,4};

  vector<int> v4; // {}
  v4 = v3; // {1,2,4} ---deep copy:v4ê°€ ë°”ê»´ë„ v3ì— ì˜í–¥ì£¼ì§€ì•ŠìŒ.
  cout << v4[0] << v4[1] << v4[2] << '\n';
  v4.pop_back(); // {1,2}
  v4.clear(); // {}
}
```

## ìˆœíšŒ

size()-1ì‚¬ìš©ì‹œ ìœ ì˜.

```C++
vector<int> v1 = {1,2,3,4,5,6};

for(int e: v1)
    cout << e << ' ';
for(int& e: v1)//ì›ë³¸ì´ ë“¤ì–´ê°.
    cout << e << ' ';
for(int i=0;i<v1.size();i++)
    cout << v1[i] << ' ';
for(int i=0;i<=v1.size()-1;i++) //size()í•¨ìˆ˜ëŠ” unsigned intë¥¼ ë°˜í™˜í•˜ëŠ”ë°, í¬ê¸°ê°€0ì¼ë•Œ -1í•´ë²„ë¦¬ë©´, 4294967295ê°€ ë¨.
    cout << v1[i]<<' ';
```

## if(1)

ê°’ì´ 0ì´ë©´ false, 0ì´ì•„ë‹ˆë©´ true.

# 0x04 ì—°ê²°ë¦¬ìŠ¤íŠ¸

## íŠ¹ì§•

kë²ˆì§¸ ì›ì†Œë¥¼ í™•ì¸/ë³€ê²½í•˜ê¸°ìœ„í•´ O(k)ê°€ í•„ìš”í•¨.  
kë²ˆì§¸ ì›ì†Œë¥¼ ì¶”ê°€/ì‚­ì œëŠ” O(1).  
ë©”ëª¨ë¦¬ìƒ ì—°ì†í•˜ì§€ì•Šì•„, cache hit rateê°€ ë‚®ì§€ë§Œ í• ë‹¹ì´ ë‹¤ì†Œ ì‰¬ì›€.
ì„ì˜ìœ„ì¹˜ì— ì¶”ê°€/ì‚­ì œê°€ ë§ë‹¤ë©´, ì—°ê²°ë¦¬ìŠ¤íŠ¸ë¥¼ ê³ ë ¤í•´ë³´ëŠ”ê²ƒì´ ì¢‹ìŒ.

## ì¢…ë¥˜

ë‹¨ì¼ì—°ê²°ë¦¬ìŠ¤íŠ¸:ë‹¤ìŒì›ì†Œ
ì´ì¤‘ì—°ê²°ë¦¬ìŠ¤íŠ¸: ì´ì „ì›ì†Œ, ë‹¤ìŒì›ì†Œ
ì›í˜•ì—°ê²°ë¦¬ìŠ¤íŠ¸: ë§¨ë§ˆì§€ë§‰ì›ì†Œì˜ ë‹¤ìŒì›ì†Œê°€ ì²«ì›ì†Œê°€ ë¨.

## ë°°ì—´ vs ë¦¬ìŠ¤íŠ¸

ë°°ì—´ê³¼ ë¦¬ìŠ¤íŠ¸ëŠ” ì„ í˜• ìë£Œêµ¬ì¡°.  
íŠ¸ë¦¬ ê·¸ë˜í”„ëŠ” ë¹„ì„ í˜• ìë£Œêµ¬ì¡°.

## STL list

ë‚´ë¶€êµ¬í˜„ì´ ì´ì¤‘ì—°ê²°ë¦¬ìŠ¤íŠ¸ë¡œ êµ¬í˜„ì´ ë˜ì–´ìˆë‹¤.

```c++
#include <bits/stdc++.h>
using namespace std;

int main(void) {
  list<int> L = {1,2}; // 1 2
  list<int>::iterator t = L.begin(); // tëŠ” 1ì„ ê°€ë¦¬í‚¤ëŠ” ì¤‘
  L.push_front(10); // 10 1 2
  cout << *t << '\n'; // tê°€ ê°€ë¦¬í‚¤ëŠ” ê°’ = 1ì„ ì¶œë ¥
  L.push_back(5); // 10 1 2 5
  L.insert(t, 6); // tê°€ ê°€ë¦¬í‚¤ëŠ” ê³³ ì•ì— 6ì„ ì‚½ì…, 10 6 1 2 5
  t++; // të¥¼ 1ì¹¸ ì•ìœ¼ë¡œ ì „ì§„, í˜„ì¬ tê°€ ê°€ë¦¬í‚¤ëŠ” ê°’ì€ 2
  t = L.erase(t); // tê°€ ê°€ë¦¬í‚¤ëŠ” ê°’ì„ ì œê±°, ê·¸ ë‹¤ìŒ ì›ì†Œì¸ 5ì˜ ìœ„ì¹˜ë¥¼ ë°˜í™˜
                  // 10 6 1 5, tê°€ ê°€ë¦¬í‚¤ëŠ” ê°’ì€ 5
  cout << *t << '\n'; // 5
  for(auto i : L) cout << i << ' ';
  cout << '\n';
  for(list<int>::iterator it = L.begin(); it != L.end(); it++)
    cout << *it << ' ';
}
```

## ì•¼ë§¤ ì—°ê²°ë¦¬ìŠ¤íŠ¸êµ¬í˜„ì½”ë“œ

```c++
#include <bits/stdc++.h>
using namespace std;

const int MX = 1000005;
int dat[MX], pre[MX], nxt[MX];
int unused = 1;

void insert(int addr, int num){
  dat[unused] = num;
  pre[unused] = addr;
  nxt[unused] = nxt[addr];
  if(nxt[addr] != -1) pre[nxt[addr]] = unused;
  nxt[addr] = unused;
  unused++;
}

void erase(int addr){
  nxt[pre[addr]] = nxt[addr];
  if(nxt[addr] != -1) pre[nxt[addr]] = pre[addr];
}

void traverse(){
  int cur = nxt[0];
  while(cur != -1){
    cout << dat[cur] << ' ';
    cur = nxt[cur];
  }
  cout << "\n\n";
}

void insert_test(){
  cout << "****** insert_test *****\n";
  insert(0, 10); // 10(address=1)
  traverse();
  insert(0, 30); // 30(address=2) 10
  traverse();
  insert(2, 40); // 30 40(address=3) 10
  traverse();
  insert(1, 20); // 30 40 10 20(address=4)
  traverse();
  insert(4, 70); // 30 40 10 20 70(address=5)
  traverse();
}

void erase_test(){
  cout << "****** erase_test *****\n";
  erase(1); // 30 40 20 70
  traverse();
  erase(2); // 40 20 70
  traverse();
  erase(4); // 40 70
  traverse();
  erase(5); // 40
  traverse();
}

int main(void) {
  fill(pre, pre+MX, -1);
  fill(nxt, nxt+MX, -1);
  insert_test();
  erase_test();
}
```

# 0x05 ìŠ¤íƒ

## íŠ¹ì§•

ì›ì†Œ ì¶”ê°€/ì œê±° O(1)
ì œì¼ ìƒë‹¨ì˜ ì›ì†Œí™•ì¸ O(1)

## ë°°ì—´ë¡œ ìŠ¤íƒì„ êµ¬í˜„

```C++
#include <bits/stdc++.h>
using namespace std;

const int MX = 1000005;
int dat[MX];
int pos = 0;

void push(int x){
  dat[pos++] = x;
}

void pop(){
  pos--;
}

int top(){
  return dat[pos-1];
}

void test(){
  push(5); push(4); push(3);
  cout << top() << '\n'; // 3
  pop(); pop();
  cout << top() << '\n'; // 5
  push(10); push(12);
  cout << top() << '\n'; // 12
  pop();
  cout << top() << '\n'; // 10
}

int main(void) {
	test();
}
```

## STL stack

```C++
#include <bits/stdc++.h>
using namespace std;

int main(void) {
  stack<int> S;
  S.push(10); // 10
  S.push(20); // 10 20
  S.push(30); // 10 20 30
  cout << S.size() << '\n'; // 3
  if(S.empty()) cout << "S is empty\n";
  else cout << "S is not empty\n"; // S is not empty
  S.pop(); // 10 20
  cout << S.top() << '\n'; // 20
  S.pop(); // 10
  cout << S.top() << '\n'; // 10
  S.pop(); // empty
  if(S.empty()) cout << "S is empty\n"; // S is empty
  cout << S.top() << '\n'; // runtime error ë°œìƒ
}
```

ìŠ¤íƒì´ ë¹„ì–´ìˆì„ë•Œ, pop()ì´ë‚˜ top()ì„ í˜¸ì¶œí•˜ë©´, ëŸ°íƒ€ì„ì—ëŸ¬ê°€ ë°œìƒ.

# 0x06 í

[cppí ë˜í¼ëŸ°ìŠ¤](https://cplusplus.com/reference/queue/queue/)  
ë³´í†µ íëŠ” BFSë‘, Flood Fillí• ë•Œ ì“°ê²Œë˜ëŠ”ë°, ë‘˜ë‹¤ ì½”í…Œ ë‹¨ê³¨ë¬¸ì œ.  
ìŠ¤íƒê³¼ ë§ˆì°¬ê°€ì§€ë¡œ, íê°€ ë¹„ì–´ìˆì„ë•Œ frontë‚˜ backë‚˜ popì„ í˜¸ì¶œí•˜ë©´, ëŸ°íƒ€ì„ì—ëŸ¬ê°€ ë°œìƒ.

## íŠ¹ì§•

- FIFO(first in first out)
- ì›ì†Œì˜ ì¶”ê°€/ì œê±° O(1).
- ì œì¼ ì•/ë’¤ì˜ ì›ì†Œí™•ì¸ì´ O(1)
- rear: ì¶”ê°€ë˜ëŠ”ìª½. ë’¤ìª½.
- front: ì œê±°ë˜ëŠ”ìª½. ì•ìª½.

## ë°°ì—´ë¡œ íë¥¼ êµ¬í˜„

```c++
#include <bits/stdc++.h>
using namespace std;

const int MX = 1000005;
int dat[MX];
int head = 0, tail = 0;

void push(int x){
  dat[tail++] = x;
}

void pop(){
  head++;
}

int front(){
  return dat[head];
}

int back(){
  return dat[tail-1];
}

void test(){
  push(10); push(20); push(30);
  cout << front() << '\n'; // 10
  cout << back() << '\n'; // 30
  pop(); pop();
  push(15); push(25);
  cout << front() << '\n'; // 30
  cout << back() << '\n'; // 25
}

int main(void) {
  test();
}
```

## STL queue

```C++
#include <bits/stdc++.h>
using namespace std;

int main(void) {
  queue<int> Q;
  Q.push(10); // 10
  Q.push(20); // 10 20
  Q.push(30); // 10 20 30
  cout << Q.size() << '\n'; // 3
  if(Q.empty()) cout << "Q is empty\n";
  else cout << "Q is not empty\n"; // Q is not empty
  Q.pop(); // 20 30
  cout << Q.front() << '\n'; // 20
  cout << Q.back() << '\n'; // 30
  Q.push(40); // 20 30 40
  Q.pop(); // 30 40
  cout << Q.front() << '\n'; // 30
}
```

# 0x07 ë±

## íŠ¹ì§•

deque: double ended Queue
ì–‘ìª½ëì—ì„œ ì‚½ì…ê³¼ ì‚­ì œê°€ ê°€ëŠ¥.

## ë°°ì—´ë¡œ ë±ì„ êµ¬í˜„

ë°°ì—´ì˜ ì¸ë±ìŠ¤ì¤‘ì•™ì—ì„œ, head, tailì„ ë†“ê³ , ì¢Œìš°ë¡œ í™•ì¥í•˜ëŠ” ëª¨ìŠµ.

```C++
#include <bits/stdc++.h>
using namespace std;

const int MX = 1000005;
int dat[2*MX+1];
int head = MX, tail = MX;

void push_front(int x){
  dat[--head] = x;
}

void push_back(int x){
  dat[tail++] = x;
}

void pop_front(){
  head++;
}

void pop_back(){
  tail--;
}

int front(){
  return dat[head];
}

int back(){
  return dat[tail-1];
}

void test(){
  push_back(30); // 30
  cout << front() << '\n'; // 30
  cout << back() << '\n'; // 30
  push_front(25); // 25 30
  push_back(12); // 25 30 12
  cout << back() << '\n'; // 12
  push_back(62); // 25 30 12 62
  pop_front(); // 30 12 62
  cout << front() << '\n'; // 30
  pop_front(); // 12 62
  cout << back() << '\n'; // 62
}

int main(void){
  test();
}
```

## STL deque

```c++
#include <bits/stdc++.h>
using namespace std;

int main(void){
  deque<int> DQ;
  DQ.push_front(10); // 10
  DQ.push_back(50); // 10 50
  DQ.push_front(24); // 24 10 50
  for(auto x : DQ) cout << x << ' ';
  cout << DQ.size() << '\n'; // 3
  if(DQ.empty()) cout << "DQ is empty\n";
  else cout << "DQ is not empty\n"; // DQ is not empty
  DQ.pop_front(); // 10 50
  DQ.pop_back(); // 10
  cout << DQ.back() << '\n'; // 10
  DQ.push_back(72); // 10 72
  cout << DQ.front() << '\n'; // 10
  DQ.push_back(12); // 10 72 12
  DQ[2] = 17; // 10 72 17
  DQ.insert(DQ.begin()+1, 33); // 10 33 72 17
  DQ.insert(DQ.begin()+4, 60); // 10 33 72 17 60
  for(auto x : DQ) cout << x << ' ';
  cout << '\n';
  DQ.erase(DQ.begin()+3); // 10 33 72 60
  cout << DQ[3] << '\n'; // 60
  DQ.clear(); // DQì˜ ëª¨ë“  ì›ì†Œ ì œê±°
}
```

STL dequeì€ ë§¤ìš° ë…íŠ¹í•˜ê²Œë„ double ended queueë¼ëŠ” ëŠë‚Œë³´ë‹¤ëŠ” vectorë‘ ë¹„ìŠ·í•œë° frontì—ì„œë„ O(1)ì— ì¶”ê°€ì™€ ì œê±°ê°€ ê°€ëŠ¥í•œ ëŠë‚Œì´ ê°•í•©ë‹ˆë‹¤.  
insert, erase, ì¸ë±ìŠ¤ì ‘ê·¼ ë˜í•œ ê°€ëŠ¥í•©ë‹ˆë‹¤. ì‹¬ì§€ì–´ frontì—ì„œ ì¶”ê°€/ì œê±°ê°€ O(1) ê°€ëŠ¥í•©ë‹ˆë‹¤.
vectorëŠ” ëª¨ë“  ì›ì†Œë“¤ì´ ë©”ëª¨ë¦¬ìƒì— ì—°ì†í•˜ê²Œ ë°°ì¹˜ë˜ì–´ ìˆì§€ë§Œ, dequeueëŠ” ì—°ì†ë°°ì¹˜ê°€ ì•„ë‹™ë‹ˆë‹¤.

ì„¤ëª…ì°¸ê³ : [vector vs deque](https://cplusplus.com/reference/deque/deque/)

# 0x08 ìŠ¤íƒì˜í™œìš©(ìˆ˜ì‹ì˜ ê´„í˜¸ìŒ)

## ì˜¬ë°”ë¥¸ ê´„í˜¸ìŒ íŒë³„ë²•

1. ì—¬ëŠ” ê´„í˜¸ê°€ ë‚˜ì˜¤ë©´ ìŠ¤íƒì— ì¶”ê°€.
2. ë‹«ëŠ” ê´„í˜¸ê°€ ë‚˜ì™”ì„ ê²½ìš°,  
   2.1. ìŠ¤íƒì´ ë¹„ì–´ìˆìœ¼ë©´ ì˜¬ë°”ë¥´ì§€ ì•Šì€ ê´„í˜¸ ìŒ.  
   2.2. ìŠ¤íƒì˜ topì´ ì§ì´ ë§ì§€ì•ŠëŠ” ê´„í˜¸ì¼ê²½ìš° ì˜¬ë°”ë¥´ì§€ì•Šì€ ê´„í˜¸ìŒ.  
   2.3. ìŠ¤íƒì˜ topì´ ì§ì´ ë§ëŠ” ê´„í˜¸ì¼ê²½ìš° pop.
3. ëª¨ë“  ê³¼ì •ì„ ëë‚¸í›„ ìŠ¤íƒì— ê´„í˜¸ê°€ ë‚¨ì•„ìˆìœ¼ë©´, ì˜¬ë°”ë¥´ì§€ì•Šì€ ê´„í˜¸ìŒ. ë‚¨ì•„ìˆì§€ì•Šìœ¼ë©´ ì˜¬ë°”ë¥¸ ê´„í˜¸ìŒ.

# 0x09 BFS

BFS: Breadth First Search.  
BFSëŠ” ê·¸ë˜í”„ë¼ëŠ” ìë£Œêµ¬ì¡°ì—ì„œ ëª¨ë“ ë…¸ë“œë¥¼ ë°©ë¬¸í•˜ê¸°ìœ„í•œ ì•Œê³ ë¦¬ì¦˜.  
ë‹¤ì°¨ì› ë°°ì—´ì—ì„œ ê°ì¹¸ì„ ë°©ë¬¸í• ë•Œ, ë„ˆë¹„ë¥¼ ìš°ì„ ìœ¼ë¡œ ë°©ë¬¸í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜.

1. ì‹œì‘í•˜ëŠ” ì¹¸ì„ íì—ë„£ê³  ë°©ë¬¸í–ˆë‹¤ëŠ” í‘œì‹œë¥¼ ë‚¨ê¹€.
2. íì—ì„œ ì›ì†Œë¥¼ êº¼ë‚´ì–´, ê·¸ ì¹¸ì— ìƒí•˜ì¢Œìš°ë¡œ ì¸ì ‘í•œ ì¹¸ì— ëŒ€í•´ 3ë²ˆì„ ì§„í–‰.
3. í•´ë‹¹ì¹¸ì„ ì´ì „ì— ë°©ë¬¸í–ˆë‹¤ë©´, ì•„ë¬´ê²ƒë„ í•˜ì§€ì•Šê³ , ì²˜ìŒìœ¼ë¡œ ë°©ë¬¸í–ˆë‹¤ë©´ ë°©ë¬¸í–ˆë‹¤ëŠ” í‘œì‹œë¥¼ ë‚¨ê¸°ê³  í•´ë‹¹ì¹¸ì„ íì— ì‚½ì….
4. íì˜ ë¹Œë•Œê¹Œì§€ 2ë²ˆì„ ë°˜ë³µ.
   ëª¨ë“  ì¹¸ì´ íì— 1ë²ˆì”© ë“¤ì–´ê°€ë¯€ë¡œ ì‹œê°„ë³µì¡ë„ëŠ” ì¹¸ì´ Nê°œì¼ë–„ O(N).

## pair

utilityí—¤ë”ì— ìˆëŠ” pair.`pair<int,int> t1 = make_pair(10, 13);`  
ë‘ ìë£Œí˜•ì„ ë¬¶ì–´ì„œ ê°€ì§€ê³  ë‹¤ë‹ìˆ˜ìˆìŒ. C++11ì´ìƒì—ì„œëŠ” ê·¸ëƒ¥ ì¤‘ê´„í˜¸ì¨ì„œ ì‰½ê²Œ í•´ê²°í• ìˆ˜ë„ ìˆìŒ.  
ê°ê° ëŒ€ì†Œê´€ê³„ê°€ ì„¤ì •ë˜ì–´ìˆì–´ì„œ, ì•Œì•„ì„œ ì•ìª½ì˜ ê°’ì„ ë¨¼ì € ë¹„êµí•˜ê³ , ì´í›„ ë’¤ìª½ì˜ ê°’ì„ ë¹„êµí•¨.

## BFS C++ ì½”ë“œ

```C++
#include <bits/stdc++.h>
using namespace std;
#define X first
#define Y second // pairì—ì„œ first, secondë¥¼ ì¤„ì—¬ì„œ ì“°ê¸° ìœ„í•´ì„œ ì‚¬ìš©
int board[502][502] =
{{1,1,1,0,1,0,0,0,0,0},
 {1,0,0,0,1,0,0,0,0,0},
 {1,1,1,0,1,0,0,0,0,0},
 {1,1,0,0,1,0,0,0,0,0},
 {0,1,0,0,0,0,0,0,0,0},
 {0,0,0,0,0,0,0,0,0,0},
 {0,0,0,0,0,0,0,0,0,0} }; // 1ì´ íŒŒë€ ì¹¸, 0ì´ ë¹¨ê°„ ì¹¸ì— ëŒ€ì‘
bool vis[502][502]; // í•´ë‹¹ ì¹¸ì„ ë°©ë¬¸í–ˆëŠ”ì§€ ì—¬ë¶€ë¥¼ ì €ì¥
int n = 7, m = 10; // n = í–‰ì˜ ìˆ˜, m = ì—´ì˜ ìˆ˜
int dx[4] = {1,0,-1,0};
int dy[4] = {0,1,0,-1}; // ìƒí•˜ì¢Œìš° ë„¤ ë°©í–¥ì„ ì˜ë¯¸
int main(void){
  ios::sync_with_stdio(0);
  cin.tie(0);
  queue<pair<int,int> > Q;
  vis[0][0] = 1; // (0, 0)ì„ ë°©ë¬¸í–ˆë‹¤ê³  ëª…ì‹œ
  Q.push({0,0}); // íì— ì‹œì‘ì ì¸ (0, 0)ì„ ì‚½ì….
  while(!Q.empty()){
    pair<int,int> cur = Q.front(); Q.pop();
    cout << '(' << cur.X << ", " << cur.Y << ") -> ";
    for(int dir = 0; dir < 4; dir++){ // ìƒí•˜ì¢Œìš° ì¹¸ì„ ì‚´í´ë³¼ ê²ƒì´ë‹¤.
      int nx = cur.X + dx[dir];
      int ny = cur.Y + dy[dir]; // nx, nyì— dirì—ì„œ ì •í•œ ë°©í–¥ì˜ ì¸ì ‘í•œ ì¹¸ì˜ ì¢Œí‘œê°€ ë“¤ì–´ê°
      if(nx < 0 || nx >= n || ny < 0 || ny >= m) continue; // ë²”ìœ„ ë°–ì¼ ê²½ìš° ë„˜ì–´ê°
      if(vis[nx][ny] || board[nx][ny] != 1) continue; // ì´ë¯¸ ë°©ë¬¸í•œ ì¹¸ì´ê±°ë‚˜ íŒŒë€ ì¹¸ì´ ì•„ë‹ ê²½ìš°
      vis[nx][ny] = 1; // (nx, ny)ë¥¼ ë°©ë¬¸í–ˆë‹¤ê³  ëª…ì‹œ
      Q.push({nx,ny});
    }
  }
}
```

# 0x0A DFS

# 0x0B ì¬ê·€

# 0x0C ë°±íŠ¸ë ˆí‚¹

# 0x0D ì‹œë®¬ë ˆì´ì…˜

# 0x0E ì •ë ¬I

# 0x0F ì •ë ¬ II

# 0x10 ë‹¤ì´ë‚˜ë¯¹ í”„ë¡œê·¸ë˜ë°

# 0x11 ê·¸ë¦¬ë””

# 0x12 ìˆ˜í•™

# 0x13 ì´ë¶„íƒìƒ‰

# 0x14 íˆ¬í¬ì¸í„°

# 0x15 í•´ì‹œ

0x07ê°• ë± ì´í›„ë¡œ ìƒˆë¡œìš´ ìë£Œêµ¬ì¡°.

## ì¶©ëŒíšŒí”¼ì „ëµ

- Chaining: ê°™ì€ í•´ì‹œê°’ì„ ê°€ì§€ëŠ” í•­ëª©ë“¤ì„, ì—°ê²°ë¦¬ìŠ¤íŠ¸ë¥¼ ë‘¬ì„œ, ì¶©ëŒíšŒí”¼ë¥¼ í•˜ëŠ”ë°©ë²•.
- Open Addressing: ì¶©ëŒì´ ë°œìƒí•˜ë©´, ë‹¤ìŒìŠ¬ë¡ì„ ì°¾ì•„ ë„£ëŠ”ë°©ì‹.
  - Linear Probing: ì¶©ëŒë°œìƒì‹œ, ë¹ˆì¹¸ì„ ìˆœì°¨íƒìƒ‰í•˜ì—¬ ë„£ëŠ”ë°©ì‹.
  - Quadratic Probing: ì¶©ëŒë°œìƒì‹œ, ë‹¤ìŒë¹ˆì¹¸ì„ ì œê³±í˜•íƒœë¡œ, ê±´ë„ˆë›°ì–´ ë„£ëŠ”ë°©ì‹.
  - double Hashing: ì¶©ëŒë°œìƒì‹œ, ì´ë™í•  ì¹¸ì˜ìˆ˜ë¥¼ ìƒˆë¡œìš´í•´ì‹œí•¨ìˆ˜ë¡œ ê³„ì‚°í•˜ëŠ” ë°©ì‹.

## STL

```c++
#include <bits/stdc++.h>
using namespace std;

void unordered_set_example(){
  unordered_set<int> s;
  s.insert(-10); s.insert(100); s.insert(15); // {-10, 100, 15}
  s.insert(-10); // {-10, 100, 15}
  cout << s.erase(100) << '\n'; // {-10, 15}, 1
  cout << s.erase(20) << '\n'; // {-10, 15}, 0
  if(s.find(15) != s.end()) cout << "15 in s\n";
  else cout << "15 not in s\n";
  cout << s.size() << '\n'; // 2
  cout << s.count(50) << '\n'; // í•´ë‹¹ê°’ì´ ìˆëŠ”ì§€ì—†ëŠ”ì§€..ì¤‘ë³µì„ í—ˆìš©í•˜ì§€ì•Šê¸°ë–„ë¬¸ì—, 0or1ì¶œë ¥.
  for(auto e : s) cout << e << ' ';
  cout << '\n';
}

void unordered_multiset_example(){
  unordered_multiset<int> ms;
  ms.insert(-10); ms.insert(100); ms.insert(15); // {-10, 100, 15}
  ms.insert(-10); ms.insert(15);// {-10, -10, 100, 15, 15}
  cout << ms.size() << '\n'; // 5
  for(auto e : ms) cout << e << ' ';
  cout << '\n';
  cout << ms.erase(15) << '\n'; // {-10, -10, 100}, 2
  ms.erase(ms.find(-10)); // {-10, 100}
  ms.insert(100); // {-10, 100, 100}
  cout << ms.count(100) << '\n'; // 2
}
//ë©€í‹°ì…‹ì€, eraseë¥¼ ì£¼ì˜.

void unordered_map_example(){
  unordered_map<string, int> m;
  m["hi"] = 123;
  m["bkd"] = 1000;
  m["gogo"] = 165; // ("hi", 123), ("bkd", 1000), ("gogo", 165)
  cout << m.size() << '\n'; // 3
  m["hi"] = -7;  // ("hi", -7), ("bkd", 1000), ("gogo", 165)
  if(m.find("hi") != m.end()) cout << "hi in m\n";
  else cout << "hi not in m\n";
  m.erase("bkd"); // ("hi", 123), ("gogo", 165)
  for(auto e : m)
    cout << e.first << ' ' << e.second << '\n';
}

int main(void){
  unordered_set_example();
  unordered_multiset_example();
  unordered_map_example();
}
```

# 0x16 ì´ì§„ê²€ìƒ‰íŠ¸ë¦¬

BST: ì™¼ìª½ ìì‹ < ë¶€ëª¨ < ì˜¤ë¥¸ìª½ ìì‹ ì˜ ê·œì¹™ì„ ë”°ë¦„.  
AVLíŠ¸ë¦¬, RBíŠ¸ë¦¬: ìê°€ ê· í˜• ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬. ì‚½ì…/ì‚­ì œ ì‹œ ê· í˜• ìœ ì§€.

### ê¸°ë³¸ ìš©ì–´

| ìš©ì–´                         | ì„¤ëª…                                                          |
| ---------------------------- | ------------------------------------------------------------- |
| **ë…¸ë“œ(Node)**               | íŠ¸ë¦¬ì˜ í•œ ìš”ì†Œ. ë°ì´í„°ë¥¼ ì €ì¥í•˜ê³ , ë‹¤ë¥¸ ë…¸ë“œì™€ì˜ ê´€ê³„ë¥¼ ê°€ì§. |
| **ë£¨íŠ¸(Root)**               | íŠ¸ë¦¬ì˜ ìµœìƒìœ„ ë…¸ë“œ. ë¶€ëª¨ê°€ ì—†ìŒ.                              |
| **ê°„ì„ (Edge)**               | ë…¸ë“œ ê°„ì˜ ì—°ê²°ì„ . ë¶€ëª¨ì™€ ìì‹ ê´€ê³„ë¥¼ ë‚˜íƒ€ëƒ„.                  |
| **ë¶€ëª¨(Parent)**             | ë‹¤ë¥¸ ë…¸ë“œì˜ ë°”ë¡œ ìœ„ ê³„ì¸µ ë…¸ë“œ.                                |
| **ìì‹(Child)**              | ì–´ë–¤ ë…¸ë“œì˜ ë°”ë¡œ ì•„ë˜ ê³„ì¸µ ë…¸ë“œ.                              |
| **í˜•ì œ(Sibling)**            | ê°™ì€ ë¶€ëª¨ë¥¼ ê°€ì§„ ë…¸ë“œë“¤.                                      |
| **ë¦¬í”„(Leaf)**               | ìì‹ ë…¸ë“œê°€ ì—†ëŠ” ë…¸ë“œ. ë§ë‹¨ ë…¸ë“œ.                             |
| **ë‚´ë¶€ ë…¸ë“œ(Internal Node)** | ìì‹ì´ ìˆëŠ” ë…¸ë“œ (ë¦¬í”„ê°€ ì•„ë‹Œ ë…¸ë“œ).                          |
| **ì„œë¸ŒíŠ¸ë¦¬(Subtree)**        | íŠ¹ì • ë…¸ë“œë¥¼ ë£¨íŠ¸ë¡œ í•˜ëŠ” ë¶€ë¶„ íŠ¸ë¦¬.                            |
| **ë…¸ë“œì˜ ê¹Šì´(Depth)**       | ë£¨íŠ¸ì—ì„œ íŠ¹ì • ë…¸ë“œê¹Œì§€ì˜ ê°„ì„  ìˆ˜.                             |
| **ë…¸ë“œì˜ ë†’ì´(Height)**      | íŠ¹ì • ë…¸ë“œì—ì„œ ê°€ì¥ ë¨¼ ë¦¬í”„ê¹Œì§€ì˜ ê°„ì„  ìˆ˜.                     |
| **íŠ¸ë¦¬ì˜ ë†’ì´**              | ë£¨íŠ¸ ë…¸ë“œì˜ ë†’ì´. ì¦‰, íŠ¸ë¦¬ì—ì„œ ê°€ì¥ ê¹Šì€ ë…¸ë“œê¹Œì§€ì˜ ê±°ë¦¬.     |
| **ë ˆë²¨(Level)**              | ë£¨íŠ¸ë¶€í„°ì˜ ê±°ë¦¬ (ë£¨íŠ¸ëŠ” 0ë ˆë²¨, ê·¸ ìì‹ì€ 1ë ˆë²¨...).           |
| **ì°¨ìˆ˜(Degree)**             | ë…¸ë“œê°€ ê°€ì§„ ìì‹ ë…¸ë“œì˜ ìˆ˜.                                   |
| **íŠ¸ë¦¬ì˜ ì°¨ìˆ˜**              | íŠ¸ë¦¬ ë‚´ì—ì„œ ê°€ì¥ ë†’ì€ ì°¨ìˆ˜ë¥¼ ê°€ì§„ ë…¸ë“œì˜ ì°¨ìˆ˜.                |

### íŠ¹ì§•

BSTëŠ”, insert,erase, find, update ëª¨ë“ ì—°ì‚°ì´ O(lg N).  
ë¦¬ìŠ¤íŠ¸ì™€ ë¹„êµí•´ë³´ë©´, O(N)ì¸ ë¦¬ìŠ¤íŠ¸ë³´ë‹¤ BSTê°€ ì¢‹ë‹¤.  
í•´ì‹œì™€ ë¹„êµí•´ë³´ë©´, ëª¨ë“ ì—°ì‚°ì´ O(1)ì¸ í•´ì‹œì™€ ì°¨ì´ê°€ìˆë‹¤.  
BSTëŠ” ì›ì†Œê°€ í¬ê¸°ìˆœìœ¼ë¡œ ì •ë ¬ë˜ì–´ìˆë‹¤ëŠ” ì°¨ì´ì ì´ ìˆë‹¤.

### BSTì—ì„œ ê°€ì¥ì–´ë ¤ìš´ì—°ì‚°ì€, Erase

ë¬´í„±ëŒ€ê³  ì§€ì›Œë²„ë¦¬ë©´, íŠ¸ë¦¬êµ¬ì¡°ê°€ ê¹¨ì ¸ë²„ë¦¼.

#### case1. ìì‹ì´ ì—†ëŠ” ì •ì ì„ ì§€ìš¸ë•Œ

í•´ë‹¹ë…¸ë“œë¥¼ ì‚­ì œ. BSTêµ¬ì¡°ê°€ ìœ ì§€ë¨.

#### case 2. ìì‹ì´ 1ê°œì¸ ì •ì ì„ ì§€ìš¸ë•Œ

ìì‹ì„ ì§€ì›Œì§„ë…¸ë“œì˜ ìë¦¬ì— ì˜¬ë¦¬ë©´ ë¨.

#### case 3. ìì‹ì´ 2ê°œì¸ ì •ì ì„ ì§€ìš¸ë•Œ

ì˜¤ë¥¸ìª½ ì„œë¸ŒíŠ¸ë¦¬ì—ì„œ ê°€ì¥ ì‘ì€ ê°’ì„ ì°¾ì•„, ê·¸ ê°’ì„ ë³µì‚¬í•´ ë„£ê³ , ê·¸ ë…¸ë“œëŠ” ì‚­ì œ.

### ìê°€ê· í˜•íŠ¸ë¦¬

BSTì—ì„œ ìµœì•…ì€ í¸í–¥ëœíŠ¸ë¦¬ê°€ ë˜ì–´, O(N)ì´ ëœë‹¤. ì´ë¥¼ ë³´ì™„í•˜ê¸°ìœ„í•´ AVLì´ ë§Œë“¤ì–´ì¡Œë‹¤.  
AVLê³¼ RBíŠ¸ë¦¬ê°€ ìˆëŠ”ë°, RBíŠ¸ë¦¬ê°€ êµ¬í˜„ì€ ì¢€ë” ì–´ë µê³ , ì„±ëŠ¥ì´ ì¡°ê¸ˆë” ì¢‹ë‹¤.  
STLì˜ BSTëŠ” RBíŠ¸ë¦¬ë¡œ êµ¬í˜„ë˜ì–´ìˆë‹¤.  
setë˜í¼ëŸ°ìŠ¤: [ë§í¬](https://www.cplusplus.com/reference/set/set)
mapë˜í¼ëŸ°ìŠ¤: [ë§í¬](https://www.cplusplus.com/reference/map/map)

# 0x17 ìš°ì„ ìˆœìœ„í

ìš°ì„ ìˆœìœ„í: popì„ í• ë•Œ ê°€ì¥ë¨¼ì € ë“¤ì–´ì˜¨ì›ì†Œê°€ ë‚˜ì˜¤ëŠ”ëŒ€ì‹ , ìš°ì„ ìˆœìœ„ê°€ ê°€ì¥ë†’ì€ì›ì†Œê°€ ë‚˜ì˜¤ëŠ”í.

1. ì›ì†Œì˜ ì¶”ê°€ê°€ O(lg N)
2. ìš°ì„ ìˆœìœ„ê°€ ê°€ì¥ë†’ì€ ì›ì†Œì˜ í™•ì¸ì´ O(1)
3. ìš°ì„ ìˆœìœ„ê°€ ê°€ì¥ë†’ì€ ì›ì†Œì˜ ì œê±°ê°€ O(lg N)

## í™ì´ë¼ëŠ” ìë£Œêµ¬ì¡°ë¥¼ ì´ìš©.

ë§ì€ë¶„ë“¤ì´ BSTì™€ í—·ê°ˆë ¤í•œë‹¤.  
í™ì—ì„œì˜ ì‚½ì…ìˆœì„œëŠ”, ì™¼ìª½ë¶€í„° ì±„ìš´ë‹¤.  
BSTëŠ” í¸í–¥ë ìˆ˜ìˆì§€ë§Œ, í™ì—ì„œëŠ” ëŠ˜ ê· í˜•ì´ ë§ê²Œëœë‹¤.

### í™ì˜ ì‚½ì…ìˆœì„œ

```markdown
     01
    /  \

02 03
/ \ / \
04 05 06 07
```

### Insert

ì‚½ì…ìˆœì„œë¥¼ ë”°ë¥´ë©´ì„œ ì‚½ì…í›„, í™êµ¬ì¡°ê°€ ê¹¨ì§ˆê²½ìš°, ë¶€ëª¨ë…¸ë“œì™€ swapí•˜ì—¬, êµ¬ì¡°ë¥¼ ìœ ì§€.  
ê³„ì† ë¶€ëª¨ë…¸ë“œì™€ ë¹„êµí•˜ê¸°ë•Œë¬¸ì—, ë¹„êµì—°ì‚°ì´ O(lg N)ì¸ê²ƒì„ ì•Œìˆ˜ìˆë‹¤.

### Fetch

ë£¨íŠ¸ë…¸ë“œê°€ ìµœì†Œê°’/ìµœëŒ€ê°’ì¸ê²ƒì„ í™•ì¸í• ìˆ˜ìˆì§€ë§Œ, 3ë²ˆì§¸ë¡œ ì‘ì€ê°’ê°™ì€ ë‹¤ìŒê°’ì„ í™•ì¸í•˜ì§€ëª»í•¨.

### Erase

ê°€ì¥ ë§ˆì§€ë§‰ì— ì¶”ê°€ëœ ë…¸ë“œì™€ ìë¦¬ë¥¼ ë°”ê¾¸ê³ , ìì‹ë…¸ë“œì™€ ë¹„êµí•´ì„œ, í™êµ¬ì¡°ë¥¼ ìœ ì§€í•˜ë„ë¡ ì—°ì‚°í•¨.  
ìë¦¬ë¥¼ë°”ê¿”ì„œ ì˜¬ë¼ê°€ëŠ”ê°’ì€, ì…‹ì¤‘ì— ê°€ì¥ì‘ì€ê°’ì„ ì˜¬ë¦¼.

## ë°°ì—´ë¡œ êµ¬í˜„ë°©ë²•

0ë²ˆì§€ëŠ” ì‚¬ìš©ì•ˆí•¨.  
ë£¨íŠ¸ë…¸ë“œëŠ” 1ë²ˆì§€.  
xë²ˆì§€ì˜ ì™¼ìª½, ì˜¤ë¥¸ìª½ìì‹: 2x, 2x+1.  
xë²ˆì§€ì˜ ë¶€ëª¨: x/2.  
íŠ¹íˆ popí•¨ìˆ˜ëŠ”..ì‹¤ìˆ˜í•˜ê¸° ì‰½ë‹¤.

```c++
#include <bits/stdc++.h>
using namespace std;

int heap[100005];
int sz = 0; // heapì— ë“¤ì–´ìˆëŠ” ì›ì†Œì˜ ìˆ˜

void push(int x){
  heap[++sz] = x;
  int idx = sz;
  while(idx != 1){
    int par = idx/2;
    if(heap[par] <= heap[idx]) break;
    swap(heap[par], heap[idx]);
    idx = par;
  }
}

int top(){
  return heap[1];
}

void pop(){
  heap[1] = heap[sz--];
  int idx = 1;
  // ì™¼ìª½ ìì‹ì˜ ì¸ë±ìŠ¤(=2*idx)ê°€ sizeë³´ë‹¤ í¬ë©´ idxëŠ” ë¦¬í”„
  while(2*idx <= sz){
    int lc = 2*idx, rc = 2*idx+1; // ì™¼ìª½ ìì‹, ì˜¤ë¥¸ìª½ ìì‹
    int min_child = lc; // ë‘ ìì‹ ì¤‘ ì‘ì€ ì¸ë±ìŠ¤ë¥¼ ë‹´ì„ ì˜ˆì •
    if(rc <= sz && heap[rc] < heap[lc])
      min_child = rc;
    if(heap[idx] <= heap[min_child]) break;
    swap(heap[idx],heap[min_child]);
    idx = min_child;
  }
}

void test(){
  push(10); push(2); push(5); push(9); // {10, 2, 5, 9}
  cout << top() << '\n'; // 2
  pop(); // {10, 5, 9}
  pop(); // {10, 9}
  cout << top() << '\n'; // 9
  push(5); push(15); // {10, 9, 5, 15}
  cout << top() << '\n'; // 5
  pop(); // {10, 9, 15}
  cout << top() << '\n'; // 9
}

int main(void){
  test();
}
```

## STL ìµœëŒ€í™

`priority_queue<int>`ì€ ê¸°ë³¸ì ìœ¼ë¡œ ìµœëŒ€í™. ìµœì†Œí™ì„ ì‚¬ìš©í•˜ë ¤ë©´, `priority_queue<int, vector<int>, greater<int>>`ìœ¼ë¡œ ì„ ì–¸.

```c++
#include <bits/stdc++.h>
using namespace std;

int main(void){
  priority_queue<int> pq; // ìµœëŒ€ í™
  // priority_queue<int, vector<int>, greater<int>>ë¡œ ì„ ì–¸ì‹œ ìµœì†Œ í™
  pq.push(10); pq.push(2); pq.push(5); pq.push(9); // {10, 2, 5, 9}
  cout << pq.top() << '\n'; // 10
  pq.pop(); // {2, 5, 9}
  cout << pq.size() << '\n'; // 3
  if(pq.empty()) cout << "PQ is empty\n";
  else cout << "PQ is not empty\n";
  pq.pop(); // {2, 5}
  cout << pq.top() << '\n'; // 5
  pq.push(5); pq.push(15); // {2, 5, 5, 15}
  cout << pq.top() << '\n'; // 15
}
```

### setì´ ê¸°ëŠ¥ë„ ë§ê³ , ì‹œê°„ë³µì¡ë„ë„ ë™ì¼í•œë°..êµ³ì´ì“¸í•„ìš” ìˆë‚˜??

priority_queueëŠ” setë³´ë‹¤ ìˆ˜í–‰ì†ë„ê°€ ë¹ ë¥´ê³ , ê³µê°„ë„ ì ê²Œ ì°¨ì§€í•©ë‹ˆë‹¤.

# 0x18 ê·¸ë˜í”„

ê·¸ë˜í”„? ì •ì ê³¼ ê°„ì„ ìœ¼ë¡œ ì´ë£¨ì–´ì§„ ìë£Œêµ¬ì¡°.
ê°„ì„ (Edge), ì •ì (Vertex/Node),
ì°¨ìˆ˜(degree): ì •ì ì— ëŒ€í•´ì„œ ì´ì›ƒí•œ ì •ì ì˜ ê°œìˆ˜ê°€ ì°¨ìˆ˜.

ë„¤ë¹„ê²Œì´ì…˜ì—ì„œ ìµœë‹¨ê²½ë¡œì°¾ê¸°ì™€ ê°™ì€ ì›ì†Œì‚¬ì´ì˜ ì—°ê²°ê´€ê³„ë¥¼ ì„¤ì •í•´ì•¼í•˜ëŠ”ìƒí™©ì— ìœ ìš©í•œ ìë£Œêµ¬ì¡°.

## ë¬´ë°©í–¥ê·¸ë˜í”„, ë°©í–¥ê·¸ë˜í”„

ë¬´ë°©í–¥ê·¸ë˜í”„(UnDirected Graph), ë°©í–¥ê·¸ë˜í”„(Directed Graph)
outDegree: í•´ë‹¹ë…¸ë“œì—ì„œ ë‚˜ê°€ëŠ” ê°„ì„ ì˜ ê°œìˆ˜.
InDegree: í•´ë‹¹ë…¸ë“œì—ì„œ ë“¤ì–´ì˜¤ëŠ” ê°„ì„ ì˜ ê°œìˆ˜.

## ìˆœí™˜ê·¸ë˜í”„, ë¹„ìˆœí™˜ê·¸ë˜í”„

ìˆœí™˜ê·¸ë˜í”„(Cyclic Graph), ë¹„ìˆœí™˜ê·¸ë˜í”„(Acyclic Graph)
ìˆœí™˜ê·¸ë˜í”„(Cyclic Graph): ê·¸ë˜í”„ ì•ˆì— ì‚¬ì´í´ì´ í•˜ë‚˜ì´ìƒ ì¡´ì¬.
ë¹„ìˆœí™˜ê·¸ë˜í”„(Acyclic Graph): ê·¸ë˜í”„ì•ˆì— ì‚¬ì´í´ì´ ì¡´ì¬í•˜ì§€ì•ŠìŒ.

### ì‚¬ì´í´

ì„ì˜ì˜ í•œì ì—ì„œ ì¶œë°œí•´. ìê¸°ìì‹ ìœ¼ë¡œ ëŒì•„ì˜¬ìˆ˜ìˆëŠ” ê²½ë¡œë¥¼ ì‚¬ì´í´.

## ì™„ì „ê·¸ë˜í”„, ì—°ê²°ê·¸ë˜í”„

ì™„ì „ê·¸ë˜í”„(Complete Graph), ì—°ê²°ê·¸ë˜í”„(Conneted Graph)
ì™„ì „ê·¸ë˜í”„: ëª¨ë“  ì„œë¡œ ë‹¤ë¥¸ ë‘ ì •ì  ìŒì´ ê°„ì„ ìœ¼ë¡œ ì—°ê²°ëœ ê·¸ë˜í”„.
ì—°ê²°ê·¸ë˜í”„: ì„ì˜ì˜ ë‘ ì •ì  ì‚¬ì´ì— ê²½ë¡œê°€ í•­ìƒ ì¡´ì¬í•˜ëŠ” ê·¸ë˜í”„.

## í‘œí˜„ë²•1: ì¸ì ‘í–‰ë ¬

ë³´í†µ 1-indexedë¡œ ë²ˆí˜¸ë¥¼ ë¶™ì„.
ë‹¨ìˆœ ê·¸ë˜í”„, ì¦‰ ë‘ ì •ì  ì‚¬ì´ì˜ ê°„ì„ ì´ 1ê°œ ì´í•˜ì¸ ê·¸ë˜í”„ë¼ê³  í•  ë•Œ ì—°ê²°ëœ ë‘ ì •ì ì—ëŠ” 1ì„, ì—°ê²°ë˜ì§€ ì•Šì€ ë‘ ì •ì ì—ëŠ” 0ì„ ì£¼ë©´ ê·¸ë˜í”„ë¥¼ í‘œí˜„í•  ìˆ˜ ìˆìŒ.
ë§Œì•½, ê°„ì„ ì´ 3ê°œë©´ 3ì„ì“°ê³ , 4ê°œë©´ 4ì„ì“°ëŠ”ë°©ì‹ìœ¼ë¡œ í•´ê²°ê°€ëŠ¥.

### ë°©í–¥ê·¸ë˜í”„

```c++
int adj_matrix[10][10]={};
int v,e;
cin>>v>>e;
for(int i=0;i<e;i++){
  int u,v;
  cin >> u>>v;
  adj_matrix[u][v]=1;
}
```

```c++
int adj_matrix[10][10]={};
int v,e;
cin>>v>>e;
for(int i=0;i<e;i++){
  int u,v;
  cin >> u>>v;
  adj_matrix[u][v]=1;
  adj_matrix[v][u]=1;
}
```

## í‘œí˜„ë²•2: ì¸ì ‘ë¦¬ìŠ¤íŠ¸

ì •ì ì´ ë§ê³ , ê°„ì„ ì€ ìƒëŒ€ì ìœ¼ë¡œ ì ì€ìƒí™©ì—.

### ë°©í–¥ê·¸ë˜í”„

```c++
vector<int> adj[10];
int v,e;
cin>>v>>e;
for(int i=0;i<e;i++){
  int u,v;
  cin >> u >> v;
  adj[u].push_back(v);
}
```

### ë¬´ë°©í–¥ê·¸ë˜í”„

```c++
vector<int> adj[10];
int v,e;
cin>>v>>e;
for(int i=0;i<e;i++){
  int u,v;
  cin >> u >> v;
  adj[u].push_back(v);
  adj[v].push_back(u);
}
```

ì¸ì ‘í–‰ë ¬ê³¼ ì¸ì ‘ë¦¬ìŠ¤íŠ¸ì˜ ë¹„êµ.
ì¸ì ‘í–‰ë ¬: ë‘ ì •ì ì˜ ì—°ê²°ì—¬ë¶€ë¥¼ ìì£¼í™•ì¸í• ë•Œ. Eê°€ V^2ì— ê°€ê¹Œìš¸ë•Œ.(Edgeê°€ ë§ì„ë•Œ)
ì¸ì ‘ë¦¬ìŠ¤íŠ¸: íŠ¹ì •ì •ì ì˜ ì—°ê²°ëœ ëª¨ë“ ì •ì ì„ ìì£¼í™•ì¸í• ë•Œ. Eê°€ V^2ë³´ë‹¤ í›¨ì”¬ ì‘ì„ë•Œ.

## ê·¸ë˜í”„ì˜ BFS

1. ì‹œì‘í•˜ëŠ” ì •ì ì„ íì— ë„£ê³  ë°©ë¬¸í–ˆë‹¤ëŠ” í‘œì‹œë¥¼ ë‚¨ê¹€
2. íì—ì„œ ì •ì ì„ êº¼ë‚´ì–´ ê·¸ ì •ì ê³¼ ì—°ê²°ëœ ëª¨ë“  ì •ì ë“¤ì— ëŒ€í•´ 3ë²ˆì„ ì§„í–‰
3. í•´ë‹¹ ì •ì ì„ ì´ì „ì— ë°©ë¬¸í–ˆë‹¤ë©´ ì•„ë¬´ê²ƒë„ í•˜ì§€ ì•Šê³ , ì²˜ìŒìœ¼ë¡œ ë°©ë¬¸í–ˆë‹¤ë©´
   ë°©ë¬¸í–ˆë‹¤ëŠ” í‘œì‹œë¥¼ ë‚¨ê¸°ê³  í•´ë‹¹ ê°„ì„ íì— ì‚½ì…
4. íê°€ ë¹Œë•Œê¹Œì§€ 2ë²ˆì„ ë°˜ë³µ
   ëª¨ë“  ì •ì ì´ íì— ìµœëŒ€ 1ë²ˆì”© ë“¤ì–´ê°€ë¯€ë¡œ ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ì—ì„œ O(V+E), ì¸ì ‘ í–‰ë ¬ì—ì„œ O(v^2)ì˜ ì‹œê°„ë³µì¡ë„.

### BFS ìˆœíšŒ ì˜ˆì‹œì½”ë“œ

```c++
vector<int> adj[10];
bool vis[10];
void bfs(){
  queue<int> q;
  q.push(1);
  vis[1]=true;
  while(!q.empty()){
    int cur=q.front();
    q.pop();
    cout<< cur<< ' ';
    for(auto nxt : adj[cur]){
      if(vis[nxt]) continue;
      q.push(nxt);
      vis[nxt]=true;
    }
  }
}
```

### BFS ê±°ë¦¬ ì˜ˆì‹œì½”ë“œ

```c++
vector<int> adj[10];
int dist[10];
void bfs(){
  fill(dist,dist+10,-1);
  queue<int> q;
  q.push(1);
  dist[1]=0;
  while(!q.empty()){
    int cur = q.front();
    q.pop();
    for(auto nxt: adj[i]){
      if(dist[nxt]!=-1) continue;
      q.push(nxt);
      dist[nxt]=dist[cur]+1;
    }
  }
}
```

### BFS ì—°ê²°ê·¸ë˜í”„ê°€ ì•„ë‹ë•Œ ìˆœíšŒ

```c++
vector<int> adj[10];
bool vis[10];
int v=9;
void bfs(){
  queue<int> q;
  for(int i=1;i<=v;i++){
    if(vis[i]) continue;
    q.push(i);
    vis[i]=true;
    while(!q.empty()){
      int cur=q.front();
      q.pop();
      cout << cur << ' ';
      for(auto nxt : adj[cur]){
        if(vis[nxt]) continue;
        q.push(nxt);
        vis[nxt]=true;
      }
    }
  }
}
```

### DFSì—ì„œ ìˆœíšŒ(ë¹„ì¬ê·€)

```c++
vector<int> adj[10];
bool vis[10];
void dfs(){
  stack<int> q;
  q.push(1);
  vis[1]=true;
  while(!q.empty()){
    int cur=q.top();
    q.pop();
    cout<< cur<< ' ';
    for(auto nxt : adj[cur]){
      if(vis[nxt]) continue;
      q.push(nxt);
      vis[nxt]=true;
    }
  }
}
```

### DFSì—ì„œ, ìˆœíšŒ(ì¬ê·€)

ìŠ¤íƒë©”ëª¨ë¦¬ì œí•œì´ ì‘ê²Œ ì„¤ì •ëœê³³ì—ì„œëŠ” ì¬ê·€ëŒ€ì‹  ìŠ¤íƒì„ ì¨ì„œ ,DFSìˆœíšŒ.

```c++
vector<int> adj[10];
bool vis[10];
void dfs(int cur){
  vis[cur]=true;
  cout << cur << ' ';
  for(auto nxt: adj[cur]){
    if(vis[nxt])continue;
    dfs(nxt);
  }
}
```

### DFS ë¹„ì¬ê·€(ì¬ê·€ì™€ ê°™ì€ë°©ë¬¸ìˆœì„œë¡œ)

ì•ì„œë³¸ ë¹„ì¬ê·€ì½”ë“œëŠ”, ê´€ë…ì ìœ¼ë¡œ ìƒê°í•˜ëŠ” DFSë°©ë¬¸ìˆœì„œì™€ ë‹¤ë¥´ê²Œë°©ë¬¸í•¨.  
ê´€ë…ì  DFS ë°©ë¬¸ìˆœì„œì— ë§ëŠ” ì½”ë“œ.

```c++
vector<int> adj[10];
bool vis[10];
void dfs(){
  stack<int> s;
  s.push(1);
  while(!s.empty()){
    int cur=s.top();
    s.pop();
    if(vis[cur])continue;
    vis[cur]=true;
    cout<< cur << ' ';
    for(auto nxt : adj[cur]){
      if(vis[nxt])continue;
      s.push(nxt);
    }
  }
}
```

# 0x19 íŠ¸ë¦¬

íŠ¸ë¦¬: ë¬´ë°©í–¥ì´ë©´ì„œ ì‚¬ì´í´ì´ ì—†ëŠ” ì—°ê²°ê·¸ë˜í”„.

## BFSì˜ˆì‹œì½”ë“œ - ë¶€ëª¨ë°°ì—´ ì±„ìš°ê¸°

visë°°ì—´ì„ ë“¤ê³ ê°ˆí•„ìš”ì—†ì´, ë¶€ëª¨ê°€ ëˆ„êµ¬ì¸ì§€ë§Œ ì €ì¥í•˜ê³ ìˆìœ¼ë©´ ë¨.  
pë°°ì—´: ê°ì •ì ì˜ ë¶€ëª¨ë²ˆí˜¸ë¥¼ ì €ì¥í•  ë°°ì—´. ì´ë•Œ ë£¨íŠ¸ì˜ ë¶€ëª¨ëŠ” 0.

```c++
vector<int> adj[10];
int p[10];
void bfs(int root){
  queue<int> q;
  q.push(root);
  while(!q.empty()){
    int cur = q.front();
    q.pop();
    cout<< cur << ' ';
    for(int nxt: adj[cur]){
      if(p[cur]==nxt) continue;//ë¶€ëª¨ëŠ” ë°©ë¬¸í–ˆê¸°ì— ê±´ë„ˆëœ€.
      q.push(nxt);
      p[nxt]=cur;
    }
  }
}
```

## BFS ì˜ˆì‹œì½”ë“œ - ë¶€ëª¨ì™€ depthë°°ì—´ ì±„ìš°ê¸°

ìì‹ì˜ depthëŠ” ë¶€ëª¨depth+1ì„ì„ ì´ìš©.

```c++
vector<int> adj[10];
int p[10];
int depth[10];
void bfs(int root){
  queue<int> q;
  q.push(root);
  while(!q.empty()){
    int cur = q.front();
    q.pop();
    cout<< cur << ' ';
    for(int nxt: adj[cur]){
      if(p[cur]==nxt) continue;//ë¶€ëª¨ëŠ” ë°©ë¬¸í–ˆê¸°ì— ê±´ë„ˆëœ€.
      q.push(nxt);
      p[nxt]=cur;
      depth[nxt]=depth[cur]+1;
    }
  }
}
```

## DFSì˜ˆì‹œì½”ë“œ1 - ë¶€ëª¨ì™€ depthë°°ì—´ì±„ìš°ê¸°(ë¹„ì¬ê·€)

```c++
vector<int> adj[10];
int p[10];
int depth[10];
void dfs(int root){
  stack<int> s;
  s.push(root);
  while(!s.empty()){
    int cur=s.top();
    s.pop();
    cout << cur << ' ';
    for(int nxt : adj[cur]){
      if(p[cur]==nxt)continue;
      s.push(nxt);
      p[nxt]=cur;
      depth[nxt]=depth[cur]+1;
    }
  }
}
```

## DFSì˜ˆì‹œì½”ë“œ2 - ë¶€ëª¨ì™€ depthë°°ì—´ì±„ìš°ê¸°(ì¬ê·€)

```c++
vector<int> adj[10];
int p[10];
int depth[10];
void dfs(int cur){
  cout << cur << ' ';
  for(int nxt : adj[cur]){
    if(p[cur]==nxt)continue;
    p[nxt]=cur;
    depth[nxt]=depth[cur]+1;
    dfs(nxt);
}
```

## DFSì˜ˆì‹œì½”ë“œ3 - ë‹¨ìˆœìˆœíšŒ,ì¬ê·€

```c++
vector<int> adj[10];
void dfs(int cur,int par){
  cout << cur << ' ';
  for(int nxt : adj[cur]){
    if(par ==nxt) continue;
    dfs(nxt,cur);
}
```

## ì´ì§„íŠ¸ë¦¬ì—ì„œ ìˆœíšŒ

ìˆœíšŒ: ë ˆë²¨/ì „ìœ„/ì¤‘ìœ„/í›„ìœ„.  
adjì—ë„£ì–´ì„œ ì €ì¥ì„ í• ìˆ˜ëŠ”ìˆì§€ë§Œ,ì™¼ìª½ìì‹ ì˜¤ë¥¸ìª½ìì‹ì„ êµ¬ë¶„í• ìˆ˜ì—†ìŒ.  
lc,rcë°°ì—´ì„ êµ¬ë¶„í•˜ì—¬ ì €ì¥í•˜ë©´ ì¢‹ìŒ. (leftChild, rightChild).

## ë ˆë²¨ìˆœíšŒ

ë£¨íŠ¸ë¥¼ ì‹œì‘ì ìœ¼ë¡œ, BFSëŒë ¤ì„œ êµ¬í˜„ê°€ëŠ¥.

```c++
int lc[9]={0,2,4,6,0,0,0,0,0};
int rc[9]={0,3,5,7,0,8,0,0,0};
void bfs(){//root=1
  queue<int> q;
  q.push(1);
  while(!q.empty()){
    int cur=q.front();
    q.pop();
    cout << cur << ' ';
    if(lc[cur]) q.push(lc[cur]);
    if(rc[cur]) q.push(rc[cur]);
  }
}
```

## ì „ìœ„ìˆœíšŒ(PreOrder Traversal)

1. í˜„ì¬ ì •ì ì„ ë°©ë¬¸í•œë‹¤.
2. ì™„ìª½ ì„œë¸ŒíŠ¸ë¦¬ë¥¼ ì „ìœ„ ìˆœíšŒí•œë‹¤.
3. ì˜¤ë¥¸ìª½ ì„œë¸ŒíŠ¸ë¦¬ë¥¼ ì „ìœ„ ìˆœíšŒí•œë‹¤.
   ì „ìœ„ìˆœíšŒëŠ” DFSì™€ ë°©ë¬¸ìˆœì„œê°€ ë™ì¼.

```c++
int lc[9]={0,2,4,6,0,0,0,0,0};
int rc[9]={0,3,5,7,0,8,0,0,0};
void preorder(int cur){
  cout<< cur << ' ';
  if(lc[cur]!=0) preorder(lc[cur]);
  if(rc[cur]!=0) preorder(rc[cur]);
}
//preorder(1);
```

## ì¤‘ìœ„ìˆœíšŒ(InOrder Traversal)

1. ì™„ìª½ ì„œë¸ŒíŠ¸ë¦¬ë¥¼ ì „ìœ„ ìˆœíšŒí•œë‹¤.
2. í˜„ì¬ ì •ì ì„ ë°©ë¬¸í•œë‹¤.
3. ì˜¤ë¥¸ìª½ ì„œë¸ŒíŠ¸ë¦¬ë¥¼ ì „ìœ„ ìˆœíšŒí•œë‹¤.
   ë§Œì•½, íŠ¸ë¦¬ê°€ ì´ì§„íƒìƒ‰íŠ¸ë¦¬ì˜€ë‹¤ë©´, í¬ê¸°ìˆœìœ¼ë¡œ ë°©ë¬¸í•˜ê²Œë¨.

```c++
int lc[9]={0,2,4,6,0,0,0,0,0};
int rc[9]={0,3,5,7,0,8,0,0,0};
void inorder(int cur){
  if(lc[cur]!=0) inorder(lc[cur]);
  cout<< cur << ' ';
  if(rc[cur]!=0) inorder(rc[cur]);
}
//inorder(1);
```

## í›„ìœ„ìˆœíšŒ(PostOrder Traversal)

1. í˜„ì¬ ì •ì ì„ ë°©ë¬¸í•œë‹¤.
2. ì™„ìª½ ì„œë¸ŒíŠ¸ë¦¬ë¥¼ ì „ìœ„ ìˆœíšŒí•œë‹¤.
3. ì˜¤ë¥¸ìª½ ì„œë¸ŒíŠ¸ë¦¬ë¥¼ ì „ìœ„ ìˆœíšŒí•œë‹¤.

```c++
int lc[9]={0,2,4,6,0,0,0,0,0};
int rc[9]={0,3,5,7,0,8,0,0,0};
void postorder(int cur){
  if(lc[cur]!=0) postorder(lc[cur]);
  if(rc[cur]!=0) postorder(rc[cur]);
  cout<< cur << ' ';
}
//postorder(1);
```

# 0x1A ìœ„ìƒì •ë ¬

ìœ„ìƒì •ë ¬(Topological Sort): ë°©í–¥ê·¸ë˜í”„ì—ì„œ ê°„ì„ ìœ¼ë¡œ ì£¼ì–´ì§„ ì •ì ê°„ ì„ í›„ê´€ê³„ë¥¼ ìœ„ë°°í•˜ì§€ì•Šë„ë¡ ë‚˜ì—´í•˜ëŠ” ì •ë ¬.

í•˜ë‚˜ì˜ ê·¸ë˜í”„ì—ëŠ” ì—¬ëŸ¬ê°œì˜ ìœ„ìƒì •ë ¬ê²°ê³¼ê°€ ìˆì„ìˆ˜ ìˆìŒ.  
ì‚¬ì´í´ì´ ì¡´ì¬í• ê²½ìš°, ì˜¬ë°”ë¥¸ ìœ„ìƒì •ë ¬ì´ ì¡´ì¬í• ìˆ˜ ì—†ìŒ.  
ìš´ì˜ì²´ì œì—ì„œ ë°ë“œë½ì²˜ëŸ¼, inDegreeê°€ 0ì¸ ì¡°ê±´ì„ ì„œë¡œ ë¬¼ê³ ë¬¼ë¦¬ëŠ” ìƒí™©ì´ê¸°ë•Œë¬¸.

## DAG

DAG(Directed Acyclic Graph): ì‚¬ì´í´ì´ ì¡´ì¬í•˜ì§€ì•ŠëŠ” ë°©í–¥ê·¸ë˜í”„.

## êµ¬í˜„

1. ë§¨ ì²˜ìŒ ëª¨ë“  ê°„ì„ ì„ ì½ìœ¼ë©° indegree í…Œì´ë¸”ì„ ì±„ì›€
2. indegreeê°€ 0ì¸ ì •ì ë“¤ì„ ëª¨ë‘ íì— ë„£ìŒ
3. íì—ì„œ ì •ì ë“¤ì„ êº¼ë‚´ì–´ ìœ„ìƒ ì •ë ¬ ê²°ê³¼ì— ì¶”ê°€
4. í•´ë‹¹ ì •ì ìœ¼ë¡œë¶€í„° ì—°ê²°ëœ ëª¨ë“  ì •ì ì˜ indegree ê°’ì„ 1 ê°ì†Œì‹œí‚´. ì´ë•Œ indegreeê°€ 0ì´
   ë˜ì—ˆë‹¤ë©´ ê·¸ ì •ì ì„ íì— ì¶”ê°€
5. íê°€ ë¹Œ ë•Œ ê¹Œì§€ 3, 4ë²ˆ ê³¼ì •ì„ ë°˜ë³µ

## íŠ¹ì§•

ì‚¬ì´í´ì´ ìˆë‹¤ë©´, ìœ„ìƒì •ë ¬ê²°ê³¼ì— ëª¨ë“ ì •ì ì´ í¬í•¨ë˜ì§€ì•ŠìŒ. -> ì‚¬ì´í´íŒë‹¨ì²´í¬ë¡œ í™œìš©ê°€ëŠ¥.

n: ì •ì ì˜ê°œìˆ˜.
adj: ë‚˜ì—ê²Œì„œ ë»—ì–´ë‚˜ê°€ëŠ” ì •ì ì˜ ëª©ë¡ì´ ì €ì¥ë˜ì–´ìˆìŒ.
deg: ê° ì •ì ì˜ indegreeê°€ ì €ì¥ë˜ì–´ìˆìŒ.

```c++
vector<int> adj[10];
int deg[10];
int n;
queue<int> q;
vector<int> result;
for(int i=1;i<=n;i++){
  if(deg[i]==0) q.push(i);
}
while(!q.empty()){
  int cur=q.front(); q.pop();
  result.push_back(cur);
  for(int nxt: adj[cur]){
    deg[nxt]--;
    if(deg[nxt]==0) q.push(nxt);
  }
}
if(result.size()!=n)
  cout<< "cycle exist";
else{
  for(auto x : result) cout << x << ' ';
}
```

# 0x1B ìµœì†Œì‹ ì¥íŠ¸ë¦¬

ìµœì†Œì‹ ì¥íŠ¸ë¦¬(Minimum spanning Tree). MST.  
ìµœì†Œì‹ ì¥íŠ¸ë¦¬ë¥¼ êµ¬í•˜ëŠ” ëŒ€í‘œì ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ, í¬ë£¨ìŠ¤ì¹¼ì•Œê³ ë¦¬ì¦˜ê³¼ í”„ë¦¼ì•Œê³ ë¦¬ì¦˜ì´ ìˆìŒ.

## ì‹ ì¥íŠ¸ë¦¬ë€?

ì‹ ì¥ íŠ¸ë¦¬ëŠ” ì£¼ì–´ì§„ ë°©í–¥ì„±ì´ ì—†ëŠ” ê·¸ë˜í”„ì˜ ë¶€ë¶„ ê·¸ë˜í”„(Subgraph)ë“¤ ì¤‘ì—ì„œ ëª¨ë“  ì •ì ì„ í¬í•¨í•˜ëŠ” íŠ¸ë¦¬ë¥¼ ì˜ë¯¸í•©ë‹ˆë‹¤. ë¶€ë¶„ ê·¸ë˜í”„ëŠ” ì£¼ì–´ì§„ ê·¸ë˜í”„ì—ì„œ ì¼ë¶€ ì •ì ê³¼ ê°„ì„ ë§Œì„ íƒí•´ì„œ êµ¬ì„±í•œ ìƒˆë¡œìš´ ê·¸ë˜í”„ë¥¼ ì˜ë¯¸í•©ë‹ˆë‹¤.

## ìµœì†Œì‹ ì¥íŠ¸ë¦¬ë€?

ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ëŠ” ì‹ ì¥ íŠ¸ë¦¬ ì¤‘ì—ì„œ ê°„ì„ ì˜ í•©ì´ ìµœì†Œì¸ íŠ¸ë¦¬ë¥¼ ì˜ë¯¸í•©ë‹ˆë‹¤.
ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ëŠ” ë‹¨ì¼í•´ê°€ ì•„ë‹ˆë¼, ì—¬ëŸ¬ê²½ìš°ì˜ìˆ˜ê°€ ì¡´ì¬ê°€ëŠ¥.

## í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜

ë¹„ìš©ì´ ë‚®ì€ìˆœìœ¼ë¡œ ê°„ì„ ì„ ì •ë ¬í•´ì„œ, ì •ì ì„ Unionì—°ì‚°ìœ¼ë¡œ ê°™ì€ê·¸ë£¹ìœ¼ë¡œ ë§Œë“­ë‹ˆë‹¤.
ì´ë¯¸ ê°™ì€ ê·¸ë£¹ì´ë¼ë©´, ê°„ì„ ì„ ì œê±°í•©ë‹ˆë‹¤.
ì •ì ì´ Nê°œì¼ë–„, (N-1)ê°œ ê°„ì„ ì´ ì •í•´ì§€ë©´, ì•Œê³ ë¦¬ì¦˜ì€ ì¢…ë£Œë©ë‹ˆë‹¤.

```c++
int v,e;
//ë¹„ìš©,ì •ì 1,ì •ì 2.
tuple<int,int,int> edge[1000005];
sort(edge,edge+e);
int cnt=0;
for(int i=0;i<e;i++){
  int const,a,b;
  tie(cost,a,b)-edge[i];
  if(!is_diff_group(a,b)) continue;
  cout<<cost <<' ' << a <<' '<< b;
  cnt++;
  if(cnt==v-1)break;
}
```

ë°±ì¤€ 1197ë²ˆ.

```C#
class Program
{
    private const int bufferSize = 131072; //131072=128KB. ê²½í—˜ì  ê°€ì¥ë¹ ë¥¸ì†ë„. ê¸°ë³¸=4096=4KB.
    public static readonly StreamReader sr = new(new BufferedStream(Console.OpenStandardInput(), bufferSize));
    public static readonly StreamWriter sw = new(new BufferedStream(Console.OpenStandardOutput(), bufferSize));

    static void Main()
    {
        string[] s = sr.ReadLine().Split();
        int v = int.Parse(s[0]);
        int e = int.Parse(s[1]);
        int[] p = new int[v + 1];
        Array.Fill(p, -1);
        List<(int, int, int)> edge = new List<(int, int, int)>();
        for (int i = 0; i < e; i++)
        {
            string[] s1 = sr.ReadLine().Split();
            int a = int.Parse(s1[0]);
            int b = int.Parse(s1[1]);
            int cost = int.Parse(s1[2]);
            edge.Add((cost, a, b));
        }

        edge.Sort();//ë¹„ìš©ìˆœìœ¼ë¡œ ì •ë ¬.

        int totalCost = 0;
        foreach ((int cost, int a, int b) in edge)
        {
            if (Find(a) != Find(b))
            {
                Union(a, b);
                totalCost += cost;
            }
        }

        sw.WriteLine(totalCost);
        sw.Flush();

        int Find(int x)
        {
            if (p[x] < 0) return x; //ë£¨íŠ¸ë…¸ë“œì´ë©´, ë³¸ì¸.
            return p[x] = Find(p[x]); //ë¶€ëª¨ë…¸ë“œê°€ ë£¨íŠ¸ë…¸ë“œê°€ ì•„ë‹ë•Œ, ë¶€ëª¨ë…¸ë“œë¥¼ ë£¨íŠ¸ë…¸ë“œë¡œ ë°”ê¿”ì£¼ê³ , ë£¨íŠ¸ë…¸ë“œë¥¼ ë¦¬í„´.
        }

        void Union(int a, int b)
        {
            int rootA = Find(a);
            int rootB = Find(b);

            //ë£¨íŠ¸ê°€ ë‹¤ë¥´ë©´, í•©ì¹˜ê¸°.
            if (rootA != rootB)
            {
                p[rootB] = rootA;
            }
        }
    }
}
```

## í”„ë¦¼ ì•Œê³ ë¦¬ì¦˜

ìš°ì„ ìˆœìœ„í(Heap)ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.

1. ì„ì˜ì˜ ì •ì ì„ ì„ íƒí•´ ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ì— ì¶”ê°€, í•´ë‹¹ ì •ì ê³¼ ì—°ê²°ëœ ëª¨ë“  ê°„ì„ ì„ ìš°ì„ ìˆœìœ„ íì— ì¶”ê°€
2. ìš°ì„ ìˆœìœ„ íì—ì„œ ë¹„ìš©ì´ ê°€ì¥ ì‘ì€ ê°„ì„ ì„ ì„ íƒ
3. ë§Œì•½ í•´ë‹¹ ê°„ì„ ì´ ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ì— í¬í•¨ëœ ë‘ ì •ì ì„ ì—°ê²°í•œë‹¤ë©´ ì•„ë¬´ ê²ƒë„ í•˜ì§€ ì•Šê³  ë„˜ì–´ê°, í•´ë‹¹ ê°„ì„ ì´ ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ì— í¬í•¨ëœ ì •ì  uì™€ í¬í•¨ë˜ì§€ ì•Šì€ ì •ì  vë¥¼ ì—°ê²°í•œë‹¤ë©´ í•´ë‹¹ ê°„ì„ ê³¼ ì •ì vë¥¼ ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ì— ì¶”ê°€ í›„ ì •ì  vê³¼ ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ì— í¬í•¨ë˜ì§€ ì•ŠëŠ” ì •ì ì„ ì—°ê²°í•˜ëŠ” ëª¨ë“ ê°„ì„ ì„ ìš°ì„ ìˆœìœ„ íì— ì¶”ê°€
4. ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ì— v-1ê°œì˜ ê°„ì„ ì´ ì¶”ê°€ë  ë•Œ ê¹Œì§€ 2, 3ë²ˆ ê³¼ì •ì„ ë°˜ë³µ.

# 0x1c í”Œë¡œì´ë“œ ì•Œê³ ë¦¬ì¦˜

ëª¨ë“  ì •ì  ìŒ ì‚¬ì´ì˜ ìµœë‹¨ê±°ë¦¬ë¥¼ êµ¬í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜.  
ì‹œê°„ë³µì¡ë„: O(V^3)

### ë™ì‘ ì›ë¦¬:

1. **ì´ˆê¸°í™”**:

   - ê·¸ë˜í”„ì—ì„œ ê° ë…¸ë“œ ê°„ì˜ ê±°ë¦¬ë¥¼ ë‚˜íƒ€ë‚´ëŠ” 2D ë°°ì—´ `dist`ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
   - `dist[i][j]`ëŠ” ë…¸ë“œ `i`ì—ì„œ ë…¸ë“œ `j`ë¡œ ê°€ëŠ” ê±°ë¦¬ì…ë‹ˆë‹¤. ë§Œì•½ ì§í†µìœ¼ë¡œ ì—°ê²°ë˜ì–´ ìˆì§€ ì•Šìœ¼ë©´ ë¬´í•œëŒ€ë¡œ ì„¤ì •í•©ë‹ˆë‹¤.
   - ìê¸° ìì‹ ì—ê²Œ ê°€ëŠ” ê±°ë¦¬ëŠ” 0ìœ¼ë¡œ ì„¤ì •í•©ë‹ˆë‹¤. ì¦‰, `dist[i][i] = 0`.

2. **ì í™”ì‹**:

   - ì•Œê³ ë¦¬ì¦˜ì€ ê° ë…¸ë“œë¥¼ í•˜ë‚˜ì”© ì¤‘ê°„ ë…¸ë“œë¡œ ê³ ë ¤í•˜ë©´ì„œ, ê·¸ ë…¸ë“œë¥¼ ê²½ìœ í•  ë•Œ ë” ì§§ì€ ê²½ë¡œê°€ ìˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.
   - `dist[i][j]`ë¥¼ ì—…ë°ì´íŠ¸í•˜ëŠ” ì‹ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:
     \[
     dist[i][j] = \min(dist[i][j], dist[i][k] + dist[k][j])
     \]
     ì—¬ê¸°ì„œ `k`ëŠ” ì¤‘ê°„ ë…¸ë“œì…ë‹ˆë‹¤.

3. **ë°˜ë³µ**:
   - ì¤‘ê°„ ë…¸ë“œ `k`ë¥¼ 1ë¶€í„° `n`ê¹Œì§€(ë…¸ë“œ ìˆ˜ë§Œí¼) ì°¨ë¡€ëŒ€ë¡œ ë°˜ë³µí•˜ë©° ìœ„ì˜ ì í™”ì‹ì„ ì ìš©í•©ë‹ˆë‹¤.

### ì˜ˆì‹œ

ê°„ë‹¨í•œ ì˜ˆì‹œë¥¼ ë“¤ì–´ë³´ê² ìŠµë‹ˆë‹¤.

1. 3ê°œì˜ ë…¸ë“œ (A, B, C)ê°€ ìˆê³ , Aì—ì„œ Bë¡œ ê°€ëŠ” ê±°ë¦¬, Bì—ì„œ Cë¡œ ê°€ëŠ” ê±°ë¦¬ë§Œ ì£¼ì–´ì§„ ê·¸ë˜í”„ê°€ ìˆë‹¤ê³  í•©ì‹œë‹¤.

   - A -> B = 3
   - B -> C = 4
   - A -> C = âˆ (ì—°ê²°ë˜ì§€ ì•ŠìŒ)

2. ì´ˆê¸°í™”:

   ```
   dist = [
     [0, 3, âˆ],
     [âˆ, 0, 4],
     [âˆ, âˆ, 0]
   ]
   ```

3. ì¤‘ê°„ ë…¸ë“œ `k`ì— ëŒ€í•´ ë°˜ë³µí•˜ë©° ì—…ë°ì´íŠ¸:
   - `k = A`: Aë¥¼ ì¤‘ê°„ ë…¸ë“œë¡œ ê³ ë ¤í•˜ì§€ë§Œ, Aë¥¼ ê²½ìœ í•˜ëŠ” ê²½ë¡œëŠ” ë” ì§§ì§€ ì•ŠìŒ.
   - `k = B`: Bë¥¼ ì¤‘ê°„ ë…¸ë“œë¡œ ê³ ë ¤í•˜ë©´, A -> B -> C ê²½ë¡œê°€ ë” ì§§ìœ¼ë¯€ë¡œ `dist[A][C]`ë¥¼ 7ë¡œ ì—…ë°ì´íŠ¸.
   - `k = C`: Cë¥¼ ì¤‘ê°„ ë…¸ë“œë¡œ ê³ ë ¤í•˜ì§€ë§Œ, ì¶”ê°€ë¡œ ê°œì„ ë˜ëŠ” ê²½ë¡œëŠ” ì—†ìŒ.

ìµœì¢… ê²°ê³¼:

```
dist = [
  [0, 3, 7],
  [âˆ, 0, 4],
  [âˆ, âˆ, 0]
]
```

# 0x1D ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜

ë‹¤ìµìŠ¤íŠ¸ë¼(Dijkstra)ëŠ” ê·¸ë˜í”„ì—ì„œ í•˜ë‚˜ì˜ ì‹œì‘ ì •ì ìœ¼ë¡œë¶€í„° ë‹¤ë¥¸ ëª¨ë“  ì •ì ê¹Œì§€ì˜ ìµœë‹¨ ê±°ë¦¬ë¥¼ êµ¬í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜ì´ë‹¤.  
ìµœì†Œ í™(PriorityQueue)ì„ ì“°ë©´, ì‹œê°„ë³µì¡ë„ë¥¼ ê°œì„  ì‹œí‚¬ìˆ˜ ìˆìŒ.
ìŒì˜ ê°€ì¤‘ì¹˜ê°€ ì—†ëŠ” ê·¸ë˜í”„ì—ì„œë§Œ ë™ì‘í•˜ê³ , ìŒì˜ ê°€ì¤‘ì¹˜ê°€ìˆë‹¤ë©´, ë²¨ë§Œí¬ë“œ ì•Œê³ ë¦¬ì¦˜ì„ ì‚¬ìš©í• ìˆ˜ìˆìŒ.

ë²¨ë§Œ-í¬ë“œ ì•Œê³ ë¦¬ì¦˜(Bellman-Ford Algorithm): ë‹¤ìµìŠ¤íŠ¸ë¼ë³´ë‹¤ëŠ”, ì¡°ê¸ˆëŠë¦° ìµœë‹¨ê²½ë¡œ ì•Œê³ ë¦¬ì¦˜. ìŒì˜ ê°€ì¤‘ì¹˜(ìŒìˆ˜ ë¹„ìš©) ë„ í—ˆìš©ë˜ëŠ”ê²ƒì´ íŠ¹ì§•.  
A\*ì•Œê³ ë¦¬ì¦˜: ìµœë‹¨ê²½ë¡œì°¾ëŠ” ì•Œê³ ë¦¬ì¦˜ì´ì§€ë§Œ, ê·¼ì‚¬ì¹˜(ì¶”ì •ì¹˜)ë¥¼ ì‚¬ìš©í•´ì„œ ê¸¸ì„ ì°¾ëŠ”ê²Œ íŠ¹ì§•.

## ìœ ì‚¬ ì•Œê³ ë¦¬ì¦˜ íŠ¹ì§•

| ì•Œê³ ë¦¬ì¦˜       | ëª©ì                                   | íŠ¹ì§• ì„¤ëª…                        |
| -------------- | ------------------------------------- | -------------------------------- |
| **ë‹¤ìµìŠ¤íŠ¸ë¼** | ë‹¨ì¼ ì‹œì‘ì  â†’ ëª¨ë“  ì •ì ê¹Œì§€ ìµœë‹¨ ê±°ë¦¬ | ê°€ì¥ ë¹ ë¥´ê³  ë§ì´ ì“°ì„ (ìŒìˆ˜ X)   |
| **ë²¨ë§Œ-í¬ë“œ**  | ë‹¨ì¼ ì‹œì‘ì  â†’ ëª¨ë“  ì •ì  + ìŒìˆ˜ ê°„ì„    | ëŠë¦¬ì§€ë§Œ ìŒìˆ˜ ê°„ì„ /ì‚¬ì´í´ ê°ì§€   |
| **A\***        | ì‹œì‘ì  â†’ ëª©í‘œì ê¹Œì§€ ê²½ë¡œ íƒìƒ‰         | íœ´ë¦¬ìŠ¤í‹±(ì˜ˆì¸¡ê°’) ì´ìš©í•´ì„œ ë˜‘ë˜‘í•¨ |

## ğŸ” ì£¼ìš” ë¹„êµí‘œ

| í•­ëª©                    | ë‹¤ìµìŠ¤íŠ¸ë¼               | ë²¨ë§Œ-í¬ë“œ               | A\* (A-Star)                       |
| ----------------------- | ------------------------ | ----------------------- | ---------------------------------- |
| âœ… **ìŒìˆ˜ ê°„ì„ **        | âŒ ë¶ˆê°€ëŠ¥                | âœ… ê°€ëŠ¥                 | âŒ ê¸°ë³¸ì ìœ¼ë¡œ ì•ˆ ë¨                |
| ğŸ” **ìŒìˆ˜ ì‚¬ì´í´ íƒì§€** | âŒ ê°ì§€ ëª»í•¨             | âœ… ê°ì§€ ê°€ëŠ¥            | âŒ ê¸°ë³¸ êµ¬í˜„ì—ì„œëŠ” ë¶ˆê°€ëŠ¥          |
| ğŸ§  **ì‚¬ìš© ëª©ì **        | ëª¨ë“  ê²½ë¡œ ìµœë‹¨ ê±°ë¦¬ íƒìƒ‰ | ëª¨ë“  ê²½ë¡œ + ì‚¬ì´í´ ê²€ì¶œ | ëª©ì ì§€ê¹Œì§€ ë¹ ë¥¸ ê²½ë¡œ ì°¾ê¸° (ì‹¤ìš©ì ) |
| âš¡ **ì‹œê°„ ë³µì¡ë„**      | `O(E log V)` (í™ ì‚¬ìš©ì‹œ) | `O(V Ã— E)` (ëŠë¦¼)       | `O(E)` ë˜ëŠ” `O(log V)` ìˆ˜ì¤€        |
| ğŸ¯ **ëª©í‘œ ì§€ì •**        | ì „ì²´ ë…¸ë“œ íƒìƒ‰           | ì „ì²´ ë…¸ë“œ íƒìƒ‰          | íŠ¹ì • ëª©ì ì§€ ì§€í–¥ íƒìƒ‰ (ë¹ ë¦„)       |
| ğŸ” **íœ´ë¦¬ìŠ¤í‹± ì‚¬ìš©**    | âŒ ì—†ìŒ                  | âŒ ì—†ìŒ                 | âœ… ìˆìŒ (`f(n) = g(n) + h(n)`)     |
| ğŸ® **ê²Œì„ AI ì‚¬ìš©**     | âŒ ì˜ ì•ˆ ì”€              | âŒ ê±°ì˜ ì•ˆ ì”€           | âœ… ê±°ì˜ í‘œì¤€ (ë§µ ê²½ë¡œ ì°¾ê¸° ë“±)     |

## ìš°ì„ ìˆœìœ„ íë¥¼ ì´ìš©í•œ ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜

1. ìš°ì„ ìˆœìœ„ íì— (0, ì‹œì‘ì )ì„ ì¶”ê°€
2. ìš°ì„ ìˆœìœ„ íì—ì„œ ê±°ë¦¬ê°€ ê°€ì¥ ì‘ì€ ì›ì†Œë¥¼ ì„ íƒ, í•´ë‹¹ ê±°ë¦¬ê°€ ìµœë‹¨ ê±°ë¦¬ í…Œì´ë¸”ì— ìˆëŠ” ê°’ê³¼ ë‹¤ë¥¼ ê²½ìš° ë„˜ì–´ê°
3. ì›ì†Œê°€ ê°€ë¦¬í‚¤ëŠ” ì •ì ì„ vë¼ê³  í•  ë•Œ, vì™€ ì´ì›ƒí•œ ì •ì ë“¤ì— ëŒ€í•´ ìµœë‹¨ ê±°ë¦¬ í…Œì´ë¸” ê°’ë³´ë‹¤ vë¥¼ ê±°ì³ê°€ëŠ” ê²ƒì´ ë” ì‘ì€ ê°’ì„ ê°€ì§ˆ ê²½ìš° ìµœë‹¨ ê±°ë¦¬ í…Œì´ë¸”ì˜ ê°’ì„ ê°±ì‹ í•˜ê³  ìš°ì„ ìˆœìœ„ íì— (ê±°ë¦¬, ì´ì›ƒí•œ ì •ì ì˜ ë²ˆí™”ë¥¼ ì¶”ê°€
4. ìš°ì„ ìˆœìœ„ íê°€ ë¹Œ ë•Œ ê¹Œì§€ 2, 3ë²ˆ ê³¼ì •ì„ ë°˜ë³µ

ë°±ì¤€ 1753ë²ˆ

```C++
// Authored by : BaaaaaaaaaaarkingDog
// Co-authored by : -
// http://boj.kr/2ecc5e3e8209416d84a6858c21448d81
#include <bits/stdc++.h>
using namespace std;

#define X first
#define Y second

int v,e,st;

// {ë¹„ìš©, ì •ì  ë²ˆí˜¸}
vector<pair<int,int>> adj[20005];
const int INF = 0x3f3f3f3f;
int d[20005]; // ìµœë‹¨ ê±°ë¦¬ í…Œì´ë¸”
int main(void) {
  ios::sync_with_stdio(0);
  cin.tie(0);
  cin >> v >> e >> st;
  fill(d,d+v+1,INF);
  while(e--){
    int u,v,w;
    cin >> u >> v >> w;
    adj[u].push_back({w,v});
  }

  priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>> > pq;
  d[st] = 0;
  // ìš°ì„ ìˆœìœ„ íì— (0, ì‹œì‘ì ) ì¶”ê°€
  pq.push({d[st],st});
  while(!pq.empty()){
    auto cur = pq.top(); pq.pop(); // {ë¹„ìš©, ì •ì  ë²ˆí˜¸}
    // ê±°ë¦¬ê°€ dì— ìˆëŠ” ê°’ê³¼ ë‹¤ë¥¼ ê²½ìš° ë„˜ì–´ê°
    if(d[cur.Y] != cur.X) continue;
    for(auto nxt : adj[cur.Y]){
      if(d[nxt.Y] <= d[cur.Y]+nxt.X) continue;
      // curë¥¼ ê±°ì³ê°€ëŠ” ê²ƒì´ ë” ì‘ì€ ê°’ì„ ê°€ì§ˆ ê²½ìš°
      // d[nxt.Y]ì„ ê°±ì‹ í•˜ê³  ìš°ì„ ìˆœìœ„ íì— (ê±°ë¦¬, nxt.Y)ë¥¼ ì¶”ê°€
      d[nxt.Y] = d[cur.Y]+nxt.X;
      pq.push({d[nxt.Y],nxt.Y});
    }
  }

  for(int i = 1; i <= v; i++){
    if(d[i] == INF) cout << "INF\n";
    else cout << d[i] << "\n";
  }
}
```

# 0x1E KMP

# 0x1F íŠ¸ë¼ì´

# Appendix_A ë¬¸ìì—´ê¸°ì´ˆ

# Appendix_B ë™ì ë°°ì—´

# Appendix_C ë¹„íŠ¸ë§ˆìŠ¤í‚¹

0ê³¼ 1ì„ ë‹´ê³ ìˆëŠ” ë¹„íŠ¸ë¥¼ í™œìš©í•´ì„œ, ì—°ì‚°ì„ íš¨ìœ¨ì ìœ¼ë¡œ ì‚¬ìš©í•˜ëŠ” êµ¬í˜„ê¸°ë²•.

## 1. ë¹„íŠ¸ ì—°ì‚°

| ì—°ì‚° | ê¸°í˜¸ | ì˜ë¯¸                       | íŠ¹ì§•             |
| ---- | ---- | -------------------------- | ---------------- |
| AND  | `&`  | ë‘ ë¹„íŠ¸ê°€ ëª¨ë‘ 1ì¼ ë•Œë§Œ 1  | êµì§‘í•© ì—­í•       |
| OR   | `\|` | í•˜ë‚˜ë¼ë„ 1ì´ë©´ 1           | í•©ì§‘í•© ì—­í•       |
| XOR  | `^`  | ì„œë¡œ ë‹¤ë¥´ë©´ 1              | ì°¨ì§‘í•© or í† ê¸€   |
| NOT  | `~`  | ë¹„íŠ¸ë¥¼ ë°˜ì „ (1 â†’ 0, 0 â†’ 1) | ë³´ìˆ˜(ì»´í”Œë¦¬ë¨¼íŠ¸) |

| AND         | OR         | XOR         | NOT      |
| ----------- | ---------- | ----------- | -------- |
| `0 & 0 = 0` | `0\|0 = 0` | `0 ^ 0 = 0` | `~0 = 1` |
| `0 & 1 = 0` | `0\|1 = 1` | `0 ^ 1 = 1` | `~1 = 0` |
| `1 & 1 = 1` | `1\|1 = 1` | `1 ^ 1 = 0` | ...      |

### íŠ¹ì´ì 

NOTì´ ì‚´ì§ íŠ¹ì´í•œë°, signed ìë£Œí˜•ì—ì„œëŠ” `~x = -x-1`ì´ë‹¤.  
`~16 = -17`ì´ ë˜ëŠ”ë°, 2ì˜ë³´ìˆ˜ë°©ì‹ìœ¼ë¡œ ì €ì¥ë˜ê¸°ë•Œë¬¸ì—, `~x=-x-1`ì´ ì„±ë¦½.  
unsignedì—ì„œëŠ” ë‹¨ìˆœ ë¹„íŠ¸ë°˜ì „.

## ì‰¬í”„íŠ¸ ì—°ì‚°

| ì—°ì‚°ì | ì´ë¦„                        | ì„¤ëª…                                          |
| ------ | --------------------------- | --------------------------------------------- |
| `<<`   | Left Shift (ì™¼ìª½ ì‰¬í”„íŠ¸)    | ë¹„íŠ¸ë¥¼ ì™¼ìª½ìœ¼ë¡œ ì´ë™ (2ì˜ ì œê³± ê³±í•˜ê¸° íš¨ê³¼)   |
| `>>`   | Right Shift (ì˜¤ë¥¸ìª½ ì‰¬í”„íŠ¸) | ë¹„íŠ¸ë¥¼ ì˜¤ë¥¸ìª½ìœ¼ë¡œ ì´ë™ (2ì˜ ì œê³± ë‚˜ëˆ„ê¸° íš¨ê³¼) |

| ì—°ìŠµ          | í•´ì„¤       |
| ------------- | ---------- |
| `9 << 1 = 18` | 9 x 2 = 18 |
| `3 << 3 = 24` | 3 x 8 = 24 |
| `13 >> 1 = 6` | 13 / 2 = 6 |
| `9 >> 2 = 2`  | 9 / 4 = 2  |

### íŠ¹ì´ì 

ì‰¬í”„íŠ¸ì—°ì‚°ì€ ìë£Œí˜•ë²”ìœ„ë¥¼ ë„˜ì–´ì„œëŠ” ì‰¬í”„íŠ¸ë¥¼ í• ê²½ìš°, c++ë²„ì „ì— ë”°ë¼ ë‹¤ì–‘í•œ ê²°ê³¼ê°€ ë‚˜ì˜¬ìˆ˜ìˆë‹¤. ì•ˆì „í•˜ê²Œ 0ê³¼ ì–‘ìˆ˜ë²”ìœ„ ì•ˆì—ì„œë§ŒëŒê²Œí•˜ëŠ”ê±¸ ê¶Œì¥.

# Appendix_D Union-Find

Unionì—°ì‚° : ë‘ ê·¸ë£¹ì„í•©ì¹˜ëŠ” ì—°ì‚°.
Find ì—°ì‚°: ì›ì†Œê°€ ì†í•´ìˆëŠ” ê·¸ë£¹ì„ ì•Œì•„ë‚´ëŠ” ì—°ì‚°. ~= ë‚´ê°€ì†í•œ íŠ¸ë¦¬ì˜ ë£¨íŠ¸.

## Union êµ¬í˜„

SimpleUnionê³¼ ë­í¬ê¸°ë°˜ë³‘í•©ë°©ì‹ì˜ Unionì€ í° ì°¨ì´ëŠ” ì—†ë‹¤.

## ê²½ë¡œì••ì¶•.by gpt.

```C#
int Find(int x)
{
    if (p[x] < 0) return x;//ë£¨íŠ¸ë…¸ë“œì´ë©´, ë³¸ì¸.
    return p[x] = Find(p[x]);//ë¶€ëª¨ë…¸ë“œê°€ ë£¨íŠ¸ë…¸ë“œê°€ ì•„ë‹ë•Œ, ë¶€ëª¨ë…¸ë“œë¥¼ ë£¨íŠ¸ë…¸ë“œë¡œ ë°”ê¿”ì£¼ê³ , ë£¨íŠ¸ë…¸ë“œë¥¼ ë¦¬í„´.
}

void Union(int a, int b)
{
    int rootA = Find(a);
    int rootB = Find(b);

    //ë£¨íŠ¸ê°€ ë‹¤ë¥´ë©´, í•©ì¹˜ê¸°.
    if (rootA != rootB)
    {
        p[rootB] = rootA;
    }
}
```

## ë­í¬ê¸°ë°˜ ë³‘í•©. by gpt.

```C#
void Union(int a, int b)
{
    int rootA = Find(a);
    int rootB = Find(b);

    if (rootA == rootB) return;

    int rankA = -p[rootA];
    int rankB = -p[rootB];

    if (rankA > rankB)
    {
        p[rootB] = rootA; // rootBë¥¼ rootA ì•„ë˜ì— ë¶™ì„
    }
    else if (rankA < rankB)
    {
        p[rootA] = rootB; // rootAë¥¼ rootB ì•„ë˜ì— ë¶™ì„
    }
    else
    {
        // ê°™ì€ ë­í¬ë©´ ì•„ë¬´ ìª½ì´ë‚˜ ë¶™ì´ê³  ë­í¬ ì¦ê°€
        p[rootB] = rootA;
        p[rootA]--;
    }
}
```
