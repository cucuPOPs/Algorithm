# 0x00 오리엔테이션

강의에서는 C++로된 코드만 제공함.  
문제를 많이 풀어봐야함.  
맞은문제도 다른사람 코드를 보고, 좋은코드는 흡수하면서, 최적화된 코딩스타일을 계속 구축해가는게 좋음.  
`#include<bits/stdc++.h>` 왠만한 헤더들을 합쳐놓은 헤더.  
바킹독 본인은 visual code를 사용함.

# 0x01 기초코드작성요령1

빅오표기법, 시간복잡도, 공간복잡도.

## 정수자료형

- 범위를 넘어서게될때 오버플로우는, 에러를 띄우지않아서, 유의해서 사용.

| 자료형    | 크기         | 범위                                                   | 설명                            |
| --------- | ------------ | ------------------------------------------------------ | ------------------------------- |
| char      | 1byte = 8bit | 0 ~ 255                                                |                                 |
| short     | 2byte        | -32,768 ~ 32,767                                       |                                 |
| int       | 4byte        | -2,147,483,648 ~ 2,147,483,647                         |                                 |
| long long | 8byte        | -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 | int범위를 넘어설때 longlong사용 |

## 실수자료형

- 실수의 저장/연산과정에서 반드시 오차가 발생할수밖에 없다.
- 과학적표기법을 따름. exponent=지수부분, fraction=유효숫자부분
- 알고리즘문제에서는 double 대신 float를 써야하는경우는 전혀없음. -> 실수를 사용해야한다면 double!
- ll을 double에 담으면, 오차발생가능.
- int를 double에 담으면, 오차발생X.
- 실수비교떄는 등호사용X. 대략,,`if(abs(a-b) < 1e-12)`이면 동일처리하면 안전.

  | 자료형 | 크기  | 범위                                | 설명            |
  | ------ | ----- | ----------------------------------- | --------------- |
  | float  | 4byte | sign(1), exponent(8), fraction(23)  | 유효숫자 6자리  |
  | double | 8byte | sign(1), exponent(11), fraction(52) | 유효숫자 15자리 |

# 0x02 기초코드작성요령2

swap1은 원본수정하지않음. swap2,swap3는 원본수정됨.

```C++
void swap1(int a,int b)
{
    int tmp = a;
    a = b;
    b = tmp;
}
```

```C++
void swap2(int* a,int* b)
{
    int tmp = *a;
    *a = *b;
    *b = tmp;
}
```

```C++
void swap3(int& a,int& b)
{
    int tmp = a;
    a = b;
    b = tmp;
}
```

## STL - vector

```C++
vector<int> v(100);
v[20]=10;
v[60]=-4;
```

### STL을 함수인자로넘길때

```C++
void func1(vector<int> v)
{
    v[10]=7;
}
int main(void)
{
    vector<int> v(100);
    func1(v);
    cout << v[10];// 0
}
```

- func1로 인자로보낼때 복사를 해서 보내기때문에, 원본에 영향을 주지않음.

```C++
bool cmp1(vector<int> v1, vector<int> v2, int idx)
{
    return v1[idx] > v2[idx];
}
bool cmp2(vector<int>& v1, vector<int>& v2, int idx)
{
    return v1[idx] > v2[idx];
}
```

- cmp1는 vector의 크기가 N일떄 O(N) 시간복잡도를 가진다. 복사를 하기때문.
- cmp2가 의도한대로 O(1)이 됨.

### 빠른입출력

입출력 속도때문에, 시간초과나는 경우가 있음.

#### ios::sync_with_stdio(false);

c에서 쓰는 printf,scanf와 c++에서 쓰는 cin,cout는 스트림이 분리되어있음.  
코드의 흐름과, 실제출력이 동일하게 동기화 하고있는데, 이를 끊어서 시간을 절약.  
동기화를 끊었으면, 두 스트림을 섞어사용하면 안됨.  
ios::sync_with_stdio(false);인데 타이핑 아낄겸 ios::sync_with_stdio(0);으로 사용.

#### cin.tie(0);

기본적으로, cin 명령을 수행하기전에 cout 버퍼를 비워줌. (입출력 순서를 맞추기위해)  
하지만, 채점서버에서는 상관없이 정답처리됨.  
그래서 cin 명령을 수행하기전에 cout 버퍼를 비우지않도록하는 코드가 cin.tie(nullptr)인데, 타이핑 아낄꼄 cin.tie(0);

### endl 쓰지마세요.

endl은 개행문자를 출력하고, 출력버퍼를 비우라는 명령이다.  
중간중간 버퍼를 비울필요가 없음. 개행문자를 사용하자.

### 출력 마지막의 공백, 줄바꿈은 상관없다.

이부분을 위한 별도의 예외처리를 할필요가 없다. 똑같이 정답으로 처리된다.

### 디버거는 굳이 사용하지않는걸 권장.

단순히 변수출력을 해서, 디버깅.

# 0x03 배열

## 배열의 성질

1 O(1)에 k번째 원소를 확인/변경가능
2 메모리 오버헤드가 거의없음
3 cache hit rate가 높음
4 메모리상 연속구간을 잡아야해서 할당에 제약이 걸림

## 기능별 시간복잡도

맨뒤에 추가/삭제 O(1)  
중간에 추가/삭제 O(N)  
조회는 O(1)

정확히는 메소드별, 시간복잡도를 생각해야함.

## 배열 직접구현코드

<details>
<summary>펼치기</summary>

```C++
#include <bits/stdc++.h>
using namespace std;

void insert(int idx, int num, int arr[], int& len){
  for(int i = len; i > idx; i--)
    arr[i] = arr[i-1];
  arr[idx] = num;
  len++;
}

void erase(int idx, int arr[], int& len){
  len--;
  for(int i = idx; i < len; i++)
    arr[i] = arr[i+1];
}

void printArr(int arr[], int& len){
  for(int i = 0; i < len; i++) cout << arr[i] << ' ';
  cout << "\n\n";
}

void insert_test(){
  cout << "***** insert_test *****\n";
  int arr[10] = {10, 20, 30};
  int len = 3;
  insert(3, 40, arr, len); // 10 20 30 40
  printArr(arr, len);
  insert(1, 50, arr, len); // 10 50 20 30 40
  printArr(arr, len);
  insert(0, 15, arr, len); // 15 10 50 20 30 40
  printArr(arr, len);
}

void erase_test(){
  cout << "***** erase_test *****\n";
  int arr[10] = {10, 50, 40, 30, 70, 20};
  int len = 6;
  erase(4, arr, len); // 10 50 40 30 20
  printArr(arr, len);
  erase(1, arr, len); // 10 40 30 20
  printArr(arr, len);
  erase(3, arr, len); // 10 40 30
  printArr(arr, len);
}

int main(void) {
  insert_test();
  erase_test();
}
```

</details>

## 배열의 초기화 팁

3번째방법인 fill함수를 권장.

```c++
int a[21];
int b[21][21];

//1번째. memset
memset(a,0,sizeof a);
memset(b,0, sizeof b);


//2번째. for방법
for(int i=0;i<21;i++)
{
    a[i]=0;
}
for(int i=0;i<21;i++)
{
    for(int j=0;j<21;j++)
    {
        b[i][j]=0;
    }
}

//3번째. fill
fill(a,a+21,0);
for(int i=0;i<21;i++)
{
    fill(b[i],b[i]+21,0);
}
```

## STL vector

그래프의 인접리스트를 저장할때 vector가 유용하지만, 그전까지는 배열로 커버가능.  
[vector래퍼사이트](https://cplusplus.com/reference/vector/vector/)

간단하게 vector 예제코드

```C++
#include <bits/stdc++.h>
using namespace std;

int main(void) {
  vector<int> v1(3, 5); // {5,5,5};
  cout << v1.size() << '\n'; // 3
  v1.push_back(7); // {5,5,5,7};

  vector<int> v2(2); // {0,0};
  v2.insert(v2.begin()+1, 3); // {0,3,0};

  vector<int> v3 = {1,2,3,4}; // {1,2,3,4}
  v3.erase(v3.begin()+2); // {1,2,4};

  vector<int> v4; // {}
  v4 = v3; // {1,2,4} ---deep copy:v4가 바껴도 v3에 영향주지않음.
  cout << v4[0] << v4[1] << v4[2] << '\n';
  v4.pop_back(); // {1,2}
  v4.clear(); // {}
}
```

## 순회

size()-1사용시 유의.

```C++
vector<int> v1 = {1,2,3,4,5,6};

for(int e: v1)
    cout << e << ' ';
for(int& e: v1)//원본이 들어감.
    cout << e << ' ';
for(int i=0;i<v1.size();i++)
    cout << v1[i] << ' ';
for(int i=0;i<=v1.size()-1;i++) //size()함수는 unsigned int를 반환하는데, 크기가0일때 -1해버리면, 4294967295가 됨.
    cout << v1[i]<<' ';
```

## if(1)

값이 0이면 false, 0이아니면 true.

# 0x04 연결리스트

## 특징

k번째 원소를 확인/변경하기위해 O(k)가 필요함.  
k번째 원소를 추가/삭제는 O(1).  
메모리상 연속하지않아, cache hit rate가 낮지만 할당이 다소 쉬움.
임의위치에 추가/삭제가 많다면, 연결리스트를 고려해보는것이 좋음.

## 종류

단일연결리스트:다음원소
이중연결리스트: 이전원소, 다음원소
원형연결리스트: 맨마지막원소의 다음원소가 첫원소가 됨.

## 배열 vs 리스트

배열과 리스트는 선형 자료구조.  
트리 그래프는 비선형 자료구조.

## STL list
내부구현이 이중연결리스트로 구현이 되어있다.
```c++
#include <bits/stdc++.h>
using namespace std;

int main(void) {
  list<int> L = {1,2}; // 1 2
  list<int>::iterator t = L.begin(); // t는 1을 가리키는 중
  L.push_front(10); // 10 1 2
  cout << *t << '\n'; // t가 가리키는 값 = 1을 출력
  L.push_back(5); // 10 1 2 5
  L.insert(t, 6); // t가 가리키는 곳 앞에 6을 삽입, 10 6 1 2 5
  t++; // t를 1칸 앞으로 전진, 현재 t가 가리키는 값은 2
  t = L.erase(t); // t가 가리키는 값을 제거, 그 다음 원소인 5의 위치를 반환
                  // 10 6 1 5, t가 가리키는 값은 5
  cout << *t << '\n'; // 5
  for(auto i : L) cout << i << ' ';
  cout << '\n';
  for(list<int>::iterator it = L.begin(); it != L.end(); it++)
    cout << *it << ' ';
}
```

## 야매 연결리스트구현코드
```c++
#include <bits/stdc++.h>
using namespace std;

const int MX = 1000005;
int dat[MX], pre[MX], nxt[MX];
int unused = 1;

void insert(int addr, int num){
  dat[unused] = num;
  pre[unused] = addr;
  nxt[unused] = nxt[addr];
  if(nxt[addr] != -1) pre[nxt[addr]] = unused;
  nxt[addr] = unused;
  unused++;
}

void erase(int addr){
  nxt[pre[addr]] = nxt[addr];
  if(nxt[addr] != -1) pre[nxt[addr]] = pre[addr];
}

void traverse(){
  int cur = nxt[0];
  while(cur != -1){
    cout << dat[cur] << ' ';
    cur = nxt[cur];
  }
  cout << "\n\n";
}

void insert_test(){
  cout << "****** insert_test *****\n";
  insert(0, 10); // 10(address=1)
  traverse();
  insert(0, 30); // 30(address=2) 10
  traverse();
  insert(2, 40); // 30 40(address=3) 10
  traverse();
  insert(1, 20); // 30 40 10 20(address=4)
  traverse();
  insert(4, 70); // 30 40 10 20 70(address=5)
  traverse();
}

void erase_test(){
  cout << "****** erase_test *****\n";
  erase(1); // 30 40 20 70
  traverse();
  erase(2); // 40 20 70
  traverse();
  erase(4); // 40 70
  traverse();
  erase(5); // 40
  traverse();
}

int main(void) {
  fill(pre, pre+MX, -1);
  fill(nxt, nxt+MX, -1);
  insert_test();
  erase_test();
}
```

# 0x05 스택
## 특징
원소 추가/제거 O(1)
제일 상단의 원소확인 O(1)

## 배열로 스택을 구현
```C++
#include <bits/stdc++.h>
using namespace std;

const int MX = 1000005;
int dat[MX];
int pos = 0;

void push(int x){
  dat[pos++] = x;
}

void pop(){
  pos--;
}

int top(){
  return dat[pos-1];
}

void test(){
  push(5); push(4); push(3);
  cout << top() << '\n'; // 3
  pop(); pop();
  cout << top() << '\n'; // 5
  push(10); push(12);
  cout << top() << '\n'; // 12
  pop();
  cout << top() << '\n'; // 10
}

int main(void) {
	test();
}
```
## STL stack
```C++
#include <bits/stdc++.h>
using namespace std;

int main(void) {
  stack<int> S;
  S.push(10); // 10
  S.push(20); // 10 20
  S.push(30); // 10 20 30
  cout << S.size() << '\n'; // 3
  if(S.empty()) cout << "S is empty\n";
  else cout << "S is not empty\n"; // S is not empty
  S.pop(); // 10 20
  cout << S.top() << '\n'; // 20
  S.pop(); // 10
  cout << S.top() << '\n'; // 10
  S.pop(); // empty
  if(S.empty()) cout << "S is empty\n"; // S is empty
  cout << S.top() << '\n'; // runtime error 발생
}
```
스택이 비어있을때, pop()이나 top()을 호출하면, 런타임에러가 발생.
